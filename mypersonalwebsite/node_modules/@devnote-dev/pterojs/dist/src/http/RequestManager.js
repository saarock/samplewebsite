"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestManager = void 0;
const axios_1 = require("axios");
const events_1 = require("events");
const Errors_1 = require("../structures/Errors");
const query_1 = require("../util/query");
const package_json_1 = require("../../package.json");
class RequestManager extends events_1.EventEmitter {
    constructor(_type, _domain, _auth) {
        super();
        this._type = _type;
        this._domain = _domain;
        this._auth = _auth;
        this.instance = axios_1.default.create({
            baseURL: `${this._domain}/api/${this._type.toLowerCase()}`
        });
        this._ping = -1;
        this._start = 0;
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    once(event, listener) {
        super.once(event, listener);
        return this;
    }
    off(event, listener) {
        super.off(event, listener);
        return this;
    }
    getHeaders() {
        return {
            'User-Agent': `PteroJS ${this._type} v${package_json_1.version}`,
            'Content-Type': 'application/json',
            'Accept': 'application/json, text/plain',
            'Authorization': `Bearer ${this._auth}`
        };
    }
    debug(...data) {
        data
            .map(d => `[HTTP] ${d}`)
            .forEach(d => super.emit('debug', d));
    }
    async _make(method, path, body) {
        const headers = this.getHeaders();
        if (body !== null && body !== undefined) {
            if (typeof body === 'string') {
                headers['Content-Type'] = 'text/plain';
            }
            else {
                body = JSON.stringify(body);
            }
            super.emit('preRequest', body);
        }
        this.debug(`requesting: ${method} ${path}`, `payload: ${body ? headers['Content-Type'] : 'none'}`);
        this._start = Date.now();
        return await this.instance.request({
            method,
            url: path,
            headers,
            data: body
        })
            .then(r => this.handleResponse(r))
            .catch(e => this.handleError(e));
    }
    async raw(method, url, body) {
        const headers = this.getHeaders();
        if (body !== null && body !== undefined) {
            if (typeof body === 'string') {
                headers['Content-Type'] = 'text/plain';
            }
            else {
                body = JSON.stringify(body);
            }
            super.emit('preRequest', body);
        }
        this.debug(`requesting: ${method} ${url}`, `payload: ${body ? headers['Content-Type'] : 'none'}`);
        this._start = Date.now();
        return await axios_1.default.request({
            url,
            method,
            headers,
            data: body
        })
            .then(r => this.handleResponse(r))
            .catch(e => this.handleError(e));
    }
    handleResponse(res) {
        this._ping = Date.now() - this._start;
        this.debug(`received status: ${res.status} (${this._ping}ms)`, `body: ${res.data ? res.headers['content-type'] : 'none'}`);
        if ([202, 204].includes(res.status))
            return;
        super.emit('postRequest', res.data);
        if (res.data.object && res.data.object === 'null_resource')
            // TODO: retry request instead of throwing an error
            throw new Errors_1.RequestError('Request returned a null resource object');
        return res.data;
    }
    handleError(err) {
        this._ping = Date.now() - this._start;
        this.debug(`received error: ${err.name} (${this._ping}ms)`, `message: ${err.message}`);
        if (err.response === undefined)
            throw new Errors_1.RequestError(`An unknown request error occurred: ${err.message}`);
        if (err.response.status >= 500)
            throw new Errors_1.RequestError(`Received an unexpected response from the API ` +
                `(code ${err.response.status})`);
        throw new Errors_1.PteroAPIError(err.response.data);
    }
    get(path, params, body, cls) {
        const query = params && cls
            ? (0, query_1.buildQuery)(params, cls.getQueryOptions())
            : '';
        return this._make('GET', path + query, body);
    }
    post(path, body) {
        return this._make('POST', path, body);
    }
    patch(path, body) {
        return this._make('PATCH', path, body);
    }
    put(path, body) {
        return this._make('PUT', path, body);
    }
    delete(path, body) {
        return this._make('DELETE', path, body);
    }
}
exports.RequestManager = RequestManager;
