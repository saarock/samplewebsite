import type { PteroApp } from '.';
import { BaseManager } from '../structures/BaseManager';
import { Dict } from '../structures/Dict';
import { Node } from '../structures/Node';
import { CreateNodeOptions, NodeConfiguration, NodeDeploymentOptions } from '../common/app';
import { FetchOptions, Filter, Include, PaginationMeta, Resolvable, Sort } from '../common';
export declare class NodeManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, Node>;
    meta: PaginationMeta;
    /**
     * Allowed filter arguments for nodes:
     * * uuid
     * * name
     * * fqdn
     * * daemonTokenId
     */
    get FILTERS(): readonly string[];
    /**
     * Allowed include arguments for nodes:
     * * allocations
     * * location
     * * servers
     *
     * Note: not all of these include options have been implemented yet.
     */
    get INCLUDES(): readonly string[];
    /**
     * Allowed sort arguments for nodes:
     * * id
     * * uuid
     * * memory
     * * disk
     */
    get SORTS(): readonly string[];
    constructor(client: PteroApp);
    /**
     * Transforms the raw node object(s) into class objects.
     * @param data The resolvable node object(s).
     * @returns The resolved node object(s).
     */
    _patch(data: any): any;
    /**
     * Resolves a node from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved node or undefined if not found.
     */
    resolve(obj: Resolvable<Node>): Node | undefined;
    /**
     * @param id The ID of the node.
     * @returns The formatted URL to the node in the admin panel.
     */
    adminURLFor(id: number): string;
    /**
     * Fetches a node from the API by its ID. This will check the cache first unless the force
     * option is specified.
     *
     * @param id The ID of the node.
     * @param [options] Additional fetch options.
     * @returns The fetched node.
     * @example
     * ```
     * app.nodes.fetch(2).then(console.log).catch(console.error);
     * ```
     */
    fetch(id: number, options?: Include<FetchOptions>): Promise<Node>;
    /**
     * Fetches a list of nodes from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched nodes.
     * @example
     * ```
     * app.nodes.fetch({ include:['servers'] })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(options?: Include<FetchOptions>): Promise<Dict<number, Node>>;
    /**
     * Fetches the deployable nodes from the API following the specified deployable
     * node options. Note that memory and disk are required for deployment options.
     * @see {@link NodeDeploymentOptions}.
     * @param options Deployable node options.
     * @returns The deployable nodes.
     * @example
     * ```
     * app.nodes.fetchDeployable({ memory: 1024, disk: 4000 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetchDeployable(options: NodeDeploymentOptions): Promise<Dict<number, Node>>;
    /**
     * Queries the API for nodes that match the specified query filters. This fetches from the
     * API directly and does not check the cache. Use cache methods for filtering and sorting.
     *
     * Available query filters:
     * * uuid
     * * name
     * * fqdn
     * * daemonTokenId
     *
     * Available sort options:
     * * id
     * * uuid
     * * memory
     * * disk
     *
     * @param entity The entity to query.
     * @param options The query options to filter by.
     * @returns The queried nodes.
     * @example
     * ```
     * app.nodes.query('nodes.pterodactyl.test', { filter: 'daemonTokenId' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    query(entity: string, options: Filter<Sort<{}>>): Promise<Dict<number, Node>>;
    /**
     * Fetches the node configuration.
     * @param id The ID of the node.
     * @returns The node configuration.
     * @example
     * ```
     * app.nodes.getConfig(2).then(console.log).catch(console.error);
     * ```
     */
    getConfig(id: number): Promise<NodeConfiguration>;
    /**
     * Creates a node.
     * @param options Create node options.
     * @see {@link CreateNodeOptions}.
     * @returns The new node.
     * @example
     * ```
     * app.nodes.create({
     *  name: 'node04',
     *  locationId: 2,
     *  public: false,
     *  fqdn: 'n4.nodes.pterodactyl.test',
     *  scheme: 'https',
     *  behindProxy: false,
     *  memory: 1024,
     *  disk: 4000,
     *  daemonSftp: 2022,
     *  daemonListen: 8080,
     *  maintenanceMode: false
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    create(options: CreateNodeOptions): Promise<Node>;
    /**
     * Updates a node with the specified options.
     * @param id The ID of the node.
     * @param options Update node options.
     * @see {@link CreateNodeOptions}.
     * @returns The updated node.
     * @example
     * ```
     * app.nodes.update(4, { maintenanceMode: true })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    update(id: number, options: Partial<CreateNodeOptions>): Promise<Node>;
    /**
     * Deletes a node.
     * Note: there must be no servers on the node for this operation to work.
     * Please ensure this before attempting to delete the node.
     * @param id The ID of the node.
     * @example
     * ```
     * app.nodes.delete(3).catch(console.error);
     * ```
     */
    delete(id: number): Promise<void>;
}
