import type { PteroApp } from '.';
import { ApplicationServer } from '../structures/ApplicationServer';
import { BaseManager } from '../structures/BaseManager';
import { Dict } from '../structures/Dict';
import { FeatureLimits, FetchOptions, Filter, Include, Limits, PaginationMeta, Resolvable, Sort } from '../common';
import { CreateServerOptions, UpdateBuildOptions, UpdateDetailsOptions, UpdateStartupOptions } from '../common/app';
export declare class ApplicationServerManager extends BaseManager {
    client: PteroApp;
    cache: Dict<number, ApplicationServer>;
    meta: PaginationMeta;
    /**
     * Allowed filter arguments for servers:
     * * name
     * * uuid
     * * uuidShort
     * * identifier (alias for uuidShort)
     * * externalId
     * * image
     */
    get FILTERS(): readonly string[];
    /**
     * Allowed include arguments for servers:
     * * allocations
     * * user
     * * subusers
     * * nest
     * * egg
     * * variables
     * * location
     * * node
     * * databases
     *
     * Note: not all of these include options have been implemented yet.
     */
    get INCLUDES(): readonly string[];
    /**
     * Allowed sort arguments for servers:
     * * id
     * * -id
     * * uuid
     * * -uuid
     *
     * Negative arguments reverse the sorted results.
     */
    get SORTS(): readonly string[];
    constructor(client: PteroApp);
    get defaultLimits(): Limits;
    get defaultFeatureLimits(): FeatureLimits;
    /**
     * Transforms the raw server object(s) into class objects.
     * @param data The resolvable server object(s).
     * @returns The resolved server object(s).
     */
    _patch(data: any): any;
    /**
     * Resolves a server from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved server or undefined if not found.
     */
    resolve(obj: Resolvable<ApplicationServer>): ApplicationServer | Dict<number, ApplicationServer> | undefined;
    /**
     * @param id The ID of the server.
     * @returns The formatted URL to the server in the admin panel.
     */
    adminURLFor(id: number): string;
    /**
     * @param id The ID of the server.
     * @returns The formatted URL to the server.
     */
    panelURLFor(id: string): string;
    /**
     * Fetches a server from the API by its ID. This will check the cache first unless the force
     * option is specified.
     *
     * @param id The ID of the server.
     * @param [options] Additional fetch options.
     * @returns The fetched server.
     * @example
     * ```
     * app.servers.fetch(12).then(console.log).catch(console.error);
     * ```
     */
    fetch(id: number, options?: Include<FetchOptions>): Promise<ApplicationServer>;
    /**
     * Fetches a server from the API by its external ID. This will check the cache first unless the
     * force option is specified.
     *
     * @param id The external ID of the server.
     * @param [options] Additional fetch options.
     * @returns The fetched server.
     * @example
     * ```
     * app.servers.fetch('minecraft').then(console.log).catch(console.error);
     * ```
     */
    fetch(id: string, options?: Include<FetchOptions>): Promise<ApplicationServer>;
    /**
     * Fetches a list of servers from the API with the given options (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched servers.
     * @example
     * ```
     * app.servers.fetch({ page: 2 }).then(console.log).catch(console.error);
     * ```
     */
    fetch(options?: Include<FetchOptions>): Promise<Dict<number, ApplicationServer>>;
    /**
     * Queries the API for servers that match the specified query filters. This fetches from the
     * API directly and does not check the cache. Use cache methods for filtering and sorting.
     *
     * Available query filters:
     * * name
     * * uuid
     * * uuidShort
     * * identifier (alias for uuidShort)
     * * externalId
     * * image
     *
     * Available sort options:
     * * id
     * * -id
     * * uuid
     * * -uuid
     *
     * @param entity The entity to query.
     * @param options The query options to filter by.
     * @returns The queried servers.
     * @example
     * ```
     * app.servers.query('ARK', { filter: 'name', sort: 'id' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    query(entity: string, options: Filter<Sort<{}>>): Promise<Dict<number, ApplicationServer>>;
    /**
     * Creates a server with the specified options.
     * @see {@link CreateServerOptions}.
     * @param options Create server options.
     * @returns The new server.
     * @example
     * ```
     * app.servers.create({
     *  name: 'ptero bot',
     *  user: 5,
     *  egg: 16,
     *  dockerImage: 'ghcr.io/parkervcp/yolks:nodejs_17',
     *  startup: 'if [ -f /home/container/package.json ];' +
     *   'then /usr/local/bin/npm install; fi;' +
     *   '/usr/local/bin/node /home/container/{{BOT_JS_FILE}}',
     *  environment:{
     *   USER_UPLOAD: false,
     *   AUTO_UPDATE: false,
     *   BOT_JS_FILE: 'index.js'
     *  },
     *  allocation:{
     *   default: 24
     *  }
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    create(options: CreateServerOptions): Promise<ApplicationServer>;
    /**
     * Updates the details of a server.
     * @see {@link UpdateDetailsOptions}.
     * @param id The ID of the server.
     * @param options Update details options.
     * @returns The updated server.
     * @example
     * ```
     * app.servers.updateDetails(12, { externalId: 'mc01' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    updateDetails(id: number, options: UpdateDetailsOptions): Promise<ApplicationServer>;
    /**
     * Updates the build configuration of a server.
     * @see {@link UpdateBuildOptions}.
     * @param id The ID of the server.
     * @param options Update build options.
     * @returns The updated server.
     * @example
     * ```
     * app.servers.updateBuild(12, {
     *  limits:{
     *   memory: 2048
     *  },
     *  addAllocations:[32]
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    updateBuild(id: number, options: UpdateBuildOptions): Promise<ApplicationServer>;
    /**
     * Updates the startup configuration of a server.
     * @see {@link UpdateStartupOptions}.
     * @param id The ID of the server.
     * @param options Update startup options.
     * @returns The updated server.
     * @example
     * ```
     * app.servers.updateStartup(12, {
     *  image: 'ghcr.io/pterodactyl/yolks:java_17',
     *  skipScripts: false
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    updateStartup(id: number, options: UpdateStartupOptions): Promise<ApplicationServer>;
    /**
     * Suspends a server.
     * @param id The ID of the server.
     * @example
     * ```
     * app.servers.suspend(14).catch(console.error);
     * ```
     */
    suspend(id: number): Promise<void>;
    /**
     * Unsuspends a server.
     * @param id The ID of the server.
     * @example
     * ```
     * app.servers.unsuspend(16).catch(console.error);
     * ```
     */
    unsuspend(id: number): Promise<void>;
    /**
     * Triggers the reinstall process of a server.
     * @param id The ID of the server.
     * @example
     * ```
     * app.servers.reinstall(17).catch(console.error);
     * ```
     */
    reinstall(id: number): Promise<void>;
    /**
     * Deletes a server.
     * @param id The ID of the server.
     * @param [force] Whether to force delete the server.
     * @example
     * ```
     * app.servers.delete(21, true).catch(console.error);
     * ```
     */
    delete(id: number, force?: boolean): Promise<void>;
}
