import type { ApplicationServer } from './ApplicationServer';
import type { PteroApp } from '../application';
import type { PteroClient } from '../client';
import { Dict } from './Dict';
import { Permissions } from './Permissions';
import { Activity, APIKey, SSHKey } from '../common/client';
export declare abstract class BaseUser {
    client: PteroApp | PteroClient;
    /** The internal ID of the user. */
    readonly id: number;
    /** The username of the user. */
    username: string;
    /** The email of the user. */
    email: string;
    /** The firstname of the user. */
    firstname: string;
    /** The lastname of the user. */
    lastname: string;
    /** The language set for the user. */
    language: string;
    constructor(client: PteroApp | PteroClient, data: any);
    _patch(data: any): void;
    /**
     * Converts the user into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON(): object;
    /** @returns The string representation of the user. */
    toString(): string;
}
export declare class User extends BaseUser {
    client: PteroApp;
    /** The UUID of the user. */
    readonly uuid: string;
    /** The date the user account was created. */
    readonly createdAt: Date;
    readonly createdTimestamp: number;
    /** The external ID of the user (if set). */
    externalId: string | null;
    /** Whether the user is an admin. */
    isAdmin: boolean;
    /** Whether the user has two-factor authentication enabled. */
    twoFactor: boolean;
    /** A dict of the servers associated with the user. */
    servers: Dict<number, ApplicationServer> | undefined;
    /** The date the user account was last updated. */
    updatedAt: Date | undefined;
    updatedTimestamp: number | undefined;
    constructor(client: PteroApp, data: any);
    _patch(data: any): void;
    /**
     * Returns a formatted URL to the user.
     * @returns The formatted URL.
     */
    get adminURL(): string;
}
export declare class SubUser {
    client: PteroClient;
    /** The UUID of the user. */
    readonly uuid: string;
    /** The identifier of the server the subuser belongs to. */
    readonly serverId: string;
    /** The date the subuser account was created. */
    readonly createdAt: Date;
    readonly createdTimestamp: number;
    /** The username of the subuser. */
    username: string;
    /** The email of the subuser. */
    email: string;
    /** The URL of the subuser account image. */
    image: string;
    /** Whether the subuser has two-factor authentication enabled. */
    enabled: boolean;
    /** The permissions the subuser has. */
    permissions: Permissions;
    constructor(client: PteroClient, serverId: string, data: any);
    _patch(data: any): void;
    /**
     * Returns a formatted URL to the subuser.
     * @returns The formatted URL.
     */
    get panelURL(): string;
    /**
     * Updates the permissions of the subuser.
     * @param permissions The permissions to set.
     * @returns The updated subuser instance.
     */
    setPermissions(...permissions: string[]): Promise<this>;
}
export declare class Account extends BaseUser {
    client: PteroClient;
    /** The internal ID of the account. */
    id: number;
    /** Whether the account has administrative permissions. */
    isAdmin: boolean;
    /** The two-factor authentication tokens for the account. */
    tokens: string[];
    /** The identifiers of API keys associated with the account. */
    apikeys: APIKey[];
    constructor(client: PteroClient);
    /**
     * Returns a formatted URL to the client account.
     * @returns The formatted URL.
     */
    get panelURL(): string;
    /**
     * Fetches any missing/partial account information.
     * @returns The updated instance.
     */
    fetch(): Promise<this>;
    /**
     * Updates the email for the account.
     * @param email The new email.
     * @param password The password for the account.
     * @returns The updated account instance.
     */
    updateEmail(email: string, password: string): Promise<this>;
    /**
     * Updates the password for the account.
     * Note: the password is **not** stored in the account instance.
     * @param oldPass The account's current password.
     * @param newPass The new password for the account.
     * @returns The updated account instance (no change).
     */
    updatePassword(oldPass: string, newPass: string): Promise<this>;
    /**
     * Fetches the 2FA image URL code.
     * @returns The two-factor image URL code.
     */
    get2FACode(): Promise<string>;
    /**
     * Enables 2FA for the account.
     * @param code The 2FA code.
     * @returns A list of 2FA codes.
     */
    enable2FA(code: string): Promise<string[]>;
    /**
     * Disables 2FA on the account and removes existing authentication tokens.
     * @param password The account password.
     */
    disable2FA(password: string): Promise<void>;
    /** @returns A list of API keys associated with the account. */
    fetchKeys(): Promise<APIKey[]>;
    /**
     * Creates an API key associated with the account.
     * @param description The description (or memo) for the key.
     * @param allowedIps A list of IP addresses that can use this key.
     * @returns The new API key.
     */
    createKey(description: string, allowedIps?: string[]): Promise<APIKey>;
    /**
     * Deletes an API key from the account.
     * @param id The identifier of the key.
     */
    deleteKey(id: string): Promise<void>;
    /** @returns A list of activity logs on the account. */
    fetchActivities(): Promise<Activity[]>;
    /** @returns A list of SSH keys associated with the account. */
    fetchSSHKeys(): Promise<SSHKey[]>;
    /**
     * Creates an SSH key associated with the account.
     * @param name The name of the key.
     * @param publicKey The public key to authorize.
     * @returns The new SSH key.
     */
    createSSHKey(name: string, publicKey: string): Promise<SSHKey>;
    /**
     * Removes an SSH key from the account.
     * @param fingerprint The fingerprint of the SSH key.
     */
    removeSSHKey(fingerprint: string): Promise<void>;
}
