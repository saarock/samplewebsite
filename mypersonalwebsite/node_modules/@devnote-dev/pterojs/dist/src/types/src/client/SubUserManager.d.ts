import type { PteroClient } from '.';
import { Dict } from '../structures/Dict';
import { SubUser } from '../structures/User';
import { FetchOptions, Resolvable } from '../common';
export declare class SubUserManager {
    client: PteroClient;
    serverId: string;
    cache: Dict<string, SubUser>;
    constructor(client: PteroClient, serverId: string);
    /**
     * Transforms the raw subuser object(s) into class objects.
     * @param data The resolvable subuser object(s).
     * @returns The resolved subuser object(s).
     */
    _patch(data: any): any;
    /**
     * Resolves a subuser from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved user or undefined if not found.
     */
    resolve(obj: Resolvable<SubUser>): SubUser | undefined;
    /**
     * Returns a formatted URL to the subuser.
     * @returns The formatted URL.
     */
    get panelURL(): string;
    /**
     * Fetches a subuser from the API by its UUID. This will check the cache first unless the
     * force option is specified.
     *
     * @param uuid The UUID of the subuser.
     * @param [options] Additional fetch options.
     * @returns The fetched subuser.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.fetch('36de5ed4-8c37-4bde-a1da-4203115a3e9d')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(uuid: string, options?: FetchOptions): Promise<SubUser>;
    /**
     * Fetches a list of subusers from the API with the given options (default is undefined).
     *
     * @param [options] Additional fetch options.
     * @returns The fetched subusers.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.fetch({ perPage: 10 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    fetch(options?: FetchOptions): Promise<Dict<number, SubUser>>;
    /**
     * Adds a user as a subuser to the server.
     * @param email The email of the account to add.
     * @param permissions Permissions for the account.
     * @returns The new subuser.
     * @example
     * ```
     * const perms = new Permissions(...Permissions.CONTROL, ...Permissions.FILES);
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.add('user@example.com', perms.value)
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    add(email: string, permissions: string[]): Promise<SubUser>;
    /**
     * Updates the permissions of a specified subuser.
     * @param id The UUID of the subuser.
     * @param permissions The permissions to set.
     * @returns The updated subuser account.
     * @example
     * ```
     * const perms = new Permissions(...Permissions.FILES, ...Permissions.BACKUPS);
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.setPermissions(
     *  '36de5ed4-8c37-4bde-a1da-4203115a3e9d',
     *  perms.value
     * )
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    setPermissions(id: string, permissions: string[]): Promise<SubUser>;
    /**
     * Removes a subuser's access to the server.
     * @param id The UUID of the subuser.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.remove('9d7b1d20-6e34-4a3a-abcd-c26ae79dc2bd')
     *  .catch(console.error);
     * ```
     */
    remove(id: string): Promise<void>;
}
