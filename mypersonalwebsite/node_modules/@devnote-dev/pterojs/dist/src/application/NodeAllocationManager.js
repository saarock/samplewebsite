"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeAllocationManager = void 0;
const BaseManager_1 = require("../structures/BaseManager");
const Dict_1 = require("../structures/Dict");
const caseConv_1 = require("../util/caseConv");
const endpoints_1 = require("./endpoints");
class NodeAllocationManager extends BaseManager_1.BaseManager {
    constructor(client) {
        super();
        this.client = client;
        this.cache = new Dict_1.Dict();
        this.meta = {
            current: 0,
            total: 0,
            count: 0,
            perPage: 0,
            totalPages: 0
        };
    }
    /** Allowed filter arguments for allocations. */
    get FILTERS() { return Object.freeze([]); }
    /** Allowed include arguments for allocations. */
    get INCLUDES() {
        return Object.freeze(['node', 'server']);
    }
    /** Allowed sort arguments for allocations. */
    get SORTS() { return Object.freeze([]); }
    _patch(node, data) {
        if (data?.meta?.pagination) {
            this.meta = caseConv_1.default.toCamelCase(data.meta.pagination, { ignore: ['current_page'] });
            this.meta.current = data.meta.pagination.current_page;
        }
        const res = new Dict_1.Dict();
        for (let o of data.data) {
            const a = caseConv_1.default.toCamelCase(o.attributes);
            res.set(a.id, a);
        }
        const all = (this.cache.get(node) || new Dict_1.Dict()).join(res);
        this.cache.set(node, all);
        return res;
    }
    /**
     * @param id The ID of the allocation.
     * @returns The formatted URL to the allocation in the admin panel.
     */
    adminURLFor(id) {
        return `${this.client.domain}/admin/nodes/view/${id}/allocation`;
    }
    /**
     * Fetches a list of allocations on a specific node from the API with the given options
     * (default is undefined).
     * @see {@link Include} and {@link FetchOptions}.
     *
     * @param [options] Additional fetch options.
     * @returns The fetched allocations.
     * @example
     * ```
     * app.allocations.fetch(4, { page: 3 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async fetch(node, options = {}) {
        if (!options.force) {
            const a = this.cache.get(node);
            if (a)
                return Promise.resolve(a);
        }
        const data = await this.client.requests.get(endpoints_1.default.nodes.allocations.main(node), options, null, this);
        return this._patch(node, data);
    }
    async fetchAvailable(node, single) {
        const all = await this.fetch(node);
        return single
            ? all.filter(a => !a.assigned).first()
            : all.filter(a => !a.assigned);
    }
    /**
     * Creates a number of allocations based on the ports specified. Note that the created
     * allocations will not be returned due to the number that can be created in a single request,
     * which can cause unwanted issues.
     * @param node The ID of the node.
     * @param ip The IP for the allocation.
     * @param ports A list of ports or port ranges for the allocation.
     * @example
     * ```
     * app.allocations.create(4, '10.0.0.1', ['8000-9000'])
     *  .catch(console.error);
     * ```
     */
    async create(node, ip, ports) {
        if (!ports.every(p => typeof p === 'string'))
            throw new TypeError('Allocation ports must be a string integer or string range.');
        for (const port of ports) {
            if (!port.includes('-'))
                continue;
            const [_start, _stop] = port.split('-');
            const start = Number(_start), stop = Number(_stop);
            if (start > stop)
                throw new RangeError('Start cannot be greater than stop.');
            if (start <= 1024 || stop > 65535)
                throw new RangeError('Port range must be between 1024 and 65535.');
            if (stop - start > 1000)
                throw new RangeError('Maximum port range exceeded (1000).');
        }
        await this.client.requests.post(endpoints_1.default.nodes.allocations.main(node), { ip, ports });
    }
    /**
     * Deletes an allocation from a node.
     * @param node The ID of the node.
     * @param id The ID of the allocation.
     * @example
     * ```
     * app.allocations.delete(4, 92).catch(console.error);
     * ```
     */
    async delete(node, id) {
        await this.client.requests.delete(endpoints_1.default.nodes.allocations.get(node, id));
        this.cache.get(node)?.delete(id);
    }
}
exports.NodeAllocationManager = NodeAllocationManager;
