"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NestEggsManager = void 0;
const BaseManager_1 = require("../structures/BaseManager");
const Dict_1 = require("../structures/Dict");
const caseConv_1 = require("../util/caseConv");
const endpoints_1 = require("./endpoints");
class NestEggsManager extends BaseManager_1.BaseManager {
    constructor(client) {
        super();
        this.client = client;
        this.cache = new Dict_1.Dict();
    }
    /** Allowed filter arguments for eggs (none). */
    get FILTERS() { return Object.freeze([]); }
    /**
     * Allowed include arguments for eggs:
     * * nest
     * * servers
     * * config
     * * script
     * * variables
     */
    get INCLUDES() {
        return Object.freeze([
            'nest', 'servers', 'config',
            'script', 'variables'
        ]);
    }
    /** Allowed sort arguments for eggs (none). */
    get SORTS() { return Object.freeze([]); }
    /**
     * Transforms the raw egg object(s) into typed objects.
     * @param data The resolvable egg object(s).
     * @returns The resolved egg object(s).
     */
    _patch(data) {
        if (data?.data) {
            const res = new Dict_1.Dict();
            for (let o of data.data) {
                let e = caseConv_1.default.toCamelCase(o.attributes);
                e.createdAt = new Date(e.createdAt);
                e.updatedAt &&= new Date(e.updatedAt);
                res.set(e.id, e);
            }
            this.cache.update(res);
            return res;
        }
        let e = caseConv_1.default.toCamelCase(data.attributes);
        e.createdAt = new Date(e.createdAt);
        e.updatedAt &&= new Date(e.updatedAt);
        this.cache.set(e.id, e);
        return e;
    }
    /**
     * @param id The ID of the egg.
     * @returns The formatted URL to the egg in the admin panel.
     */
    adminURLFor(id) {
        return `${this.client.domain}/admin/nests/egg/${id}`;
    }
    async fetch(nest, op1, op2 = {}) {
        let path = endpoints_1.default.nests.eggs.main(nest);
        if (typeof op1 === 'number') {
            if (!op2.force && this.cache.has(op1))
                return this.cache.get(op1);
            path = endpoints_1.default.nests.eggs.get(nest, op1);
        }
        else {
            if (op1)
                op2 = op1;
        }
        const data = await this.client.requests.get(path, op2, null, this);
        return this._patch(data);
    }
}
exports.NestEggsManager = NestEggsManager;
