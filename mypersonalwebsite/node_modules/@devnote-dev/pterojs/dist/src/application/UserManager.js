"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserManager = void 0;
const BaseManager_1 = require("../structures/BaseManager");
const Dict_1 = require("../structures/Dict");
const User_1 = require("../structures/User");
const Errors_1 = require("../structures/Errors");
const caseConv_1 = require("../util/caseConv");
const endpoints_1 = require("./endpoints");
class UserManager extends BaseManager_1.BaseManager {
    constructor(client) {
        super();
        this.client = client;
        this.cache = new Dict_1.Dict();
        this.meta = {
            current: 0,
            total: 0,
            count: 0,
            perPage: 0,
            totalPages: 0
        };
    }
    /**
     * Allowed filter arguments for users:
     * * email
     * * uuid
     * * username
     * * externalId
     */
    get FILTERS() {
        return Object.freeze(['email', 'uuid', 'username', 'external_id']);
    }
    /**
     * Allowed include arguments for users:
     * * servers
     */
    get INCLUDES() { return Object.freeze(['servers']); }
    /**
     * Allowed sort arguments for users:
     * * id
     * * -id
     * * uuid
     * * -uuid
     */
    get SORTS() {
        return Object.freeze(['id', '-id', 'uuid', '-uuid']);
    }
    /**
     * Transforms the raw user object(s) into class objects.
     * @param data The resolvable user object(s).
     * @returns The resolved user object(s).
     */
    _patch(data) {
        if (data?.meta?.pagination) {
            this.meta = caseConv_1.default.toCamelCase(data.meta.pagination, { ignore: ['current_page'] });
            this.meta.current = data.meta.pagination.current_page;
        }
        if (data?.data) {
            const res = new Dict_1.Dict();
            for (const o of data.data) {
                const s = new User_1.User(this.client, o.attributes);
                res.set(s.id, s);
            }
            if (this.client.options.servers.cache)
                this.cache = this.cache.join(res);
            return res;
        }
        const u = new User_1.User(this.client, data.attributes);
        if (this.client.options.servers.cache)
            this.cache.set(u.id, u);
        return u;
    }
    /**
     * Resolves a user from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved user or undefined if not found.
     */
    resolve(obj) {
        if (obj instanceof User_1.User)
            return obj;
        if (typeof obj === 'number')
            return this.cache.get(obj);
        if (typeof obj === 'string')
            return this.cache.find(s => (s.username === obj) || (s.firstname === obj) || (s.lastname === obj));
        if (obj.relationships?.user)
            return this._patch(obj.relationships.user);
        return undefined;
    }
    /**
     * @param id The ID of the user.
     * @returns The formatted URL to the user in the admin panel.
     */
    adminURLFor(id) {
        return `${this.client.domain}/admin/users/view/${id}`;
    }
    async fetch(op, ops = {}) {
        let path;
        switch (typeof op) {
            case 'number': {
                if (!ops.force && this.cache.has(op))
                    return this.cache.get(op);
                path = endpoints_1.default.users.get(op);
                break;
            }
            case 'string': {
                if (!ops.force) {
                    const u = this.cache.find(u => u.externalId === op);
                    if (u)
                        return u;
                }
                path = endpoints_1.default.users.ext(op);
                break;
            }
            case 'undefined':
            case 'object': {
                path = endpoints_1.default.users.main;
                if (op)
                    ops = op;
                break;
            }
            default:
                throw new Errors_1.ValidationError(`expected user id, external id or fetch options; got ${typeof op}`);
        }
        const data = await this.client.requests.get(path, ops, null, this);
        return this._patch(data);
    }
    /** @deprecated Use {@link UserManager.fetch}. */
    async fetchExternal(id, options) {
        return this.fetch(id, options);
    }
    /**
     * Queries the API for users that match the specified query filters. This fetches from the
     * API directly and does not check the cache. Use cache methods for filtering and sorting.
     *
     * Available query filters:
     * * email
     * * uuid
     * * username
     * * externalId
     *
     * Available sort options:
     * * id
     * * -id
     * * uuid
     * * -uuid
     *
     * @param entity The entity to query.
     * @param options The query options to filter by.
     * @returns The queried users.
     * @example
     * ```
     * app.users.query('d5f506c9', { filter: 'uuid' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async query(entity, options) {
        if (!options.sort && !options.filter)
            throw new Errors_1.ValidationError('Sort or filter is required.');
        if (options.filter === 'externalId')
            options.filter = 'external_id';
        const payload = {};
        if (options.filter)
            payload.filter = [options.filter, entity];
        if (options.sort)
            payload.sort = options.sort;
        const data = await this.client.requests.get(endpoints_1.default.users.main, payload, null, this);
        return this._patch(data);
    }
    /**
     * Creates a user account.
     * @see {@link CreateUserOptions}.
     * @param options Create user options.
     * @returns The new user.
     * @example
     * ```
     * app.users.create({
     *  email: 'user@example.com',
     *  username: 'example-user',
     *  firstname: 'example',
     *  lastname: 'user',
     *  externalId: 'example1'
     * })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async create(options) {
        const payload = caseConv_1.default.toSnakeCase(options, {
            map: {
                firstname: 'first_name',
                lastname: 'last_name',
                isAdmin: 'root_admin'
            }
        });
        const data = await this.client.requests.post(endpoints_1.default.users.main, payload);
        return this._patch(data);
    }
    /**
     * Updates the user account with the specified options.
     * @see {@link UpdateUserOptions}.
     * @param id The ID of the user.
     * @param options Update user options.
     * @returns The updated user.
     * @example
     * ```
     * app.users.update(7, { externalId: 'admin2', isAdmin: true })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async update(id, options) {
        if (!Object.keys(options).length)
            throw new Error('Too few options to update user.');
        const user = await this.fetch(id);
        options.username ||= user.username;
        options.firstname ||= user.firstname;
        options.lastname ||= user.lastname;
        options.email ||= user.email;
        options.isAdmin ??= user.isAdmin;
        if (!('externalId' in options))
            options.externalId = user.externalId;
        const payload = caseConv_1.default.toSnakeCase(options, {
            map: {
                firstname: 'first_name',
                lastname: 'last_name',
                isAdmin: 'root_admin'
            }
        });
        const data = await this.client.requests.patch(endpoints_1.default.users.get(id), payload);
        return this._patch(data);
    }
    /**
     * Deletes a user account.
     * @param id The ID of the user.
     * @example
     * ```
     * app.users.delete(8).catch(console.error);
     * ```
     */
    async delete(id) {
        await this.client.requests.delete(endpoints_1.default.users.get(id));
        this.cache.delete(id);
    }
}
exports.UserManager = UserManager;
