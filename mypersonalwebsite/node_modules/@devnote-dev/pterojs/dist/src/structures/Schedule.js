"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schedule = void 0;
const Dict_1 = require("./Dict");
const caseConv_1 = require("../util/caseConv");
const endpoints_1 = require("../client/endpoints");
class Schedule {
    constructor(client, serverId, data) {
        this.client = client;
        this.serverId = serverId;
        this.id = data.id;
        this.createdAt = new Date(data.created_at);
        this.tasks = new Dict_1.Dict();
        this._patch(data);
    }
    _patch(data) {
        if ('name' in data)
            this.name = data.name;
        if ('cron' in data)
            this.cron = caseConv_1.default.toCamelCase(data.cron);
        if ('is_active' in data)
            this.active = data.is_active;
        if ('is_processing' in data)
            this.processing = data.is_processing;
        if ('only_when_online' in data)
            this.onlyWhenOnline = data.only_when_online;
        if ('updated_at' in data)
            this.updatedAt = new Date(data.updated_at);
        if ('last_run_at' in data)
            this.lastRunAt = new Date(data.last_run_at);
        if ('next_run_at' in data)
            this.nextRunAt = new Date(data.next_run_at);
        if ('relationships' in data) {
            if ('tasks' in data.relationships)
                data.relationships.tasks.data.forEach((t) => this._resolveTask(t));
        }
    }
    _resolveTask(data) {
        const t = caseConv_1.default.toCamelCase(data.attributes, {
            map: {
                time_offset: 'offset',
                is_queued: 'queued'
            }
        });
        t.createdAt = new Date(t.createdAt);
        t.updatedAt &&= new Date(t.updatedAt);
        this.tasks.set(t.id, t);
        return t;
    }
    /** Executes the schedule immediately. */
    async execute() {
        await this.client.requests.post(endpoints_1.default.servers.schedules.exec(this.serverId, this.id));
        this.processing = true;
    }
    /**
     * Updates the schedule with the specified options.
     * @param options Update schedule options.
     * @see {@link CreateScheduleOptions UpdateScheduleOptions}.
     * @returns The updated instance.
     */
    async update(options) {
        const data = await this.client.schedules.update(this.serverId, this.id, options);
        this._patch(data.toJSON());
        return this;
    }
    /**
     * Creates a task on the schedule.
     * @param action The action the task will perform.
     * @param payload The task payload.
     * @param offset The execution time offset.
     * @returns The new task.
     */
    async createTask(action, payload, offset, sequenceId) {
        const data = await this.client.requests.post(endpoints_1.default.servers.schedules.tasks.main(this.serverId, this.id), { action, payload, time_offset: offset, sequence_id: sequenceId });
        return this._resolveTask(data);
    }
    /**
     * Updates a specified task in the schedule.
     * @param id The ID of the task.
     * @param options Update task options.
     * @returns The updated task.
     */
    async updateTask(id, options) {
        if (!Object.keys(options).length)
            throw new Error('Too few options to update schedule task.');
        const payload = caseConv_1.default.toSnakeCase(options, { map: { offset: 'time_offset' } });
        const data = await this.client.requests.post(endpoints_1.default.servers.schedules.tasks.get(this.serverId, this.id, id), payload);
        return this._resolveTask(data);
    }
    /**
     * Deletes a task from the schedule.
     * @param id The ID of the task.
     */
    async deleteTask(id) {
        await this.client.requests.delete(endpoints_1.default.servers.schedules.tasks.get(this.serverId, this.id, id));
        this.tasks.delete(id);
    }
    /**
     * Converts the schedule into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON() {
        const o = caseConv_1.default.toSnakeCase(this, {
            ignore: ['client', 'cron']
        });
        o.cron = caseConv_1.default.toSnakeCase(this.cron, {
            map: {
                week: 'day_of_week',
                month: 'day_of_month'
            }
        });
        return o;
    }
    /** @returns The string representation of the schedule. */
    toString() {
        return this.name;
    }
}
exports.Schedule = Schedule;
