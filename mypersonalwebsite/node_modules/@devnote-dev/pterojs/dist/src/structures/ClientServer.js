"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientServer = void 0;
const BackupManager_1 = require("../client/BackupManager");
const ClientDatabaseManager_1 = require("../client/ClientDatabaseManager");
const FileManager_1 = require("../client/FileManager");
const NetworkManager_1 = require("../client/NetworkManager");
const SubUserManager_1 = require("../client/SubUserManager");
const endpoints_1 = require("../client/endpoints");
const caseConv_1 = require("../util/caseConv");
class ClientServer {
    constructor(client, data) {
        this.client = client;
        this.uuid = data.uuid;
        this.identifier = data.identifier;
        this.backups = new BackupManager_1.BackupManager(client, data.identifier);
        this.databases = new ClientDatabaseManager_1.ClientDatabaseManager(client, data.identifier);
        this.files = new FileManager_1.FileManager(client, data.identifier);
        this.network = new NetworkManager_1.NetworkManager(client, data.identifier);
        this.users = new SubUserManager_1.SubUserManager(client, data.identifier);
        this._patch(data);
    }
    _patch(data) {
        if ('name' in data)
            this.name = data.name;
        if ('description' in data)
            this.description = data.description || undefined;
        if ('is_owner' in data)
            this.isOwner = data.is_owner;
        if ('node' in data)
            this.node = data.node;
        if ('sftp_details' in data)
            this.sftpDetails = data.sftp_details;
        if ('limits' in data)
            this.limits = caseConv_1.default.toCamelCase(data.limits);
        if ('feature_limits' in data)
            this.featureLimits = data.feature_limits;
        if ('egg_features' in data)
            this.eggFeatures = data.egg_features || undefined;
        if ('invocation' in data)
            this.invocation = data.invocation;
        if ('docker_image' in data)
            this.dockerImage = data.docker_image;
        if ('status' in data)
            this.status = data.status || undefined;
        if ('is_suspended' in data)
            this.suspended = data.is_suspended;
        if ('is_installing' in data)
            this.installing = data.is_installing;
        if ('is_transferring' in data)
            this.transferring = data.is_transferring;
    }
    /**
     * Returns a formatted URL to the server.
     * @returns The formatted URL.
     */
    get panelURL() {
        return `${this.client.domain}/server/${this.identifier}`;
    }
    /**
     * Fetches the server resources data.
     * @returns The server resources.
     */
    async fetchResources() {
        return await this.client.servers.fetchResources(this.identifier);
    }
    /**
     * Fetches the server startup and egg variables data.
     * @returns The startup and egg variable data.
     * @see {@link StartupData}.
     */
    async fetchStartup() {
        return await this.client.servers.fetchStartup(this.identifier);
    }
    /**
     * Sends a command to the server console.
     * @param command The command to send.
     */
    async sendCommand(command) {
        await this.client.requests.post(endpoints_1.default.servers.command(this.identifier), { command });
    }
    /**
     * Sets the power state of the server.
     * @param state The power state.
     */
    async setPowerState(state) {
        await this.client.servers.setPowerState(this.identifier, state);
        this.status = state;
    }
    /**
     * Updates the server's docker image.
     * @param image The docker image.
     */
    async setDockerImage(image) {
        await this.client.servers.setDockerImage(this.identifier, image);
        this.dockerImage = image;
    }
    /**
     * Updates a specified environment variable on the server. The key must be
     * the environment variable name in capital letters, not the normal
     * variable name.
     * @param key The environment variable key.
     * @param value The value of the environment variable.
     * @returns The updated egg variable.
     */
    async setVariable(key, value) {
        return await this.client.servers.setVariable(this.identifier, key, value);
    }
    /**
     * Updates the server's name.
     * @param name The new server name.
     */
    async rename(name) {
        await this.client.servers.rename(this.identifier, name);
        this.name = name;
    }
    /** Triggers the reinstall process for the server. */
    async reinstall() {
        await this.client.servers.reinstall(this.identifier);
        this.installing = true;
    }
    /**
     * Converts the server into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON() {
        return caseConv_1.default.toSnakeCase(this, {
            ignore: ['client'],
            map: {
                suspended: 'is_suspended',
                installing: 'is_installing'
            }
        });
    }
    /** @returns The string representation of the server. */
    toString() {
        return this.name;
    }
}
exports.ClientServer = ClientServer;
