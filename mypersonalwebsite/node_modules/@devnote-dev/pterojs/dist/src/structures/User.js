"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Account = exports.SubUser = exports.User = exports.BaseUser = void 0;
const Permissions_1 = require("./Permissions");
const Errors_1 = require("./Errors");
const caseConv_1 = require("../util/caseConv");
const endpoints_1 = require("../client/endpoints");
class BaseUser {
    constructor(client, data) {
        this.client = client;
        this.id = data.id;
        this._patch(data);
    }
    _patch(data) {
        if ('username' in data)
            this.username = data.username;
        if ('email' in data)
            this.email = data.email;
        if ('first_name' in data)
            this.firstname = data.first_name;
        if ('last_name' in data)
            this.lastname = data.last_name;
        if ('language' in data)
            this.language = data.language;
    }
    /**
     * Converts the user into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON() {
        return caseConv_1.default.toSnakeCase(this, {
            ignore: ['client'],
            map: { firstname: 'first_name', lastname: 'last_name' }
        });
    }
    /** @returns The string representation of the user. */
    toString() {
        return this.firstname + ' ' + this.lastname;
    }
}
exports.BaseUser = BaseUser;
class User extends BaseUser {
    constructor(client, data) {
        super(client, data);
        this.client = client;
        this.createdAt = new Date(data.created_at);
        this.createdTimestamp = this.createdAt.getTime();
        if ('relationships' in data) {
            this.servers = 'servers' in data.relationships
                ? this.client.servers.resolve(data)
                : undefined;
        }
    }
    _patch(data) {
        super._patch(data);
        this.externalId = data.external_id || undefined;
        this.updatedAt = data.updated_at ? new Date(data.updated_at) : undefined;
        this.updatedTimestamp = this.updatedAt?.getTime() || undefined;
        if ('root_admin' in data)
            this.isAdmin = data.root_admin;
        if ('2fa' in data)
            this.twoFactor = data['2fa'];
    }
    /**
     * Returns a formatted URL to the user.
     * @returns The formatted URL.
     */
    get adminURL() {
        return `${this.client.domain}/admin/users/view/${this.id}`;
    }
}
exports.User = User;
class SubUser {
    constructor(client, serverId, data) {
        this.client = client;
        this.uuid = data.uuid;
        this.serverId = serverId;
        this.createdAt = new Date(data.created_at);
        this.createdTimestamp = this.createdAt.getTime();
        this._patch(data);
    }
    _patch(data) {
        if ('username' in data)
            this.username = data.username;
        if ('email' in data)
            this.email = data.email;
        if ('image' in data)
            this.image = data.image;
        if ('2fa_enabled' in data)
            this.enabled = data['2fa_enabled'];
        if ('permissions' in data)
            this.permissions = new Permissions_1.Permissions(...data.permissions ?? []);
    }
    /**
     * Returns a formatted URL to the subuser.
     * @returns The formatted URL.
     */
    get panelURL() {
        return `${this.client.domain}/server/${this.serverId}/users`;
    }
    /**
     * Updates the permissions of the subuser.
     * @param permissions The permissions to set.
     * @returns The updated subuser instance.
     */
    async setPermissions(...permissions) {
        const perms = Permissions_1.Permissions.resolve(...permissions);
        if (!perms.length)
            throw new Errors_1.ValidationError('No permissions specified for the subuser.');
        const data = await this.client.requests.post(endpoints_1.default.servers.users.get(this.serverId, this.uuid), { permissions: perms });
        this._patch(data);
        return this;
    }
}
exports.SubUser = SubUser;
class Account extends BaseUser {
    constructor(client) {
        super(client, {});
        this.client = client;
        this.isAdmin = false;
        this.tokens = [];
        this.apikeys = [];
    }
    /**
     * Returns a formatted URL to the client account.
     * @returns The formatted URL.
     */
    get panelURL() {
        return `${this.client.domain}/account`;
    }
    /**
     * Fetches any missing/partial account information.
     * @returns The updated instance.
     */
    async fetch() {
        const data = await this.client.requests.get(endpoints_1.default.account.main);
        super._patch(data.attributes);
        this.id = data.attributes.id;
        this.isAdmin = data.attributes.admin;
        return this;
    }
    /**
     * Updates the email for the account.
     * @param email The new email.
     * @param password The password for the account.
     * @returns The updated account instance.
     */
    async updateEmail(email, password) {
        if (this.email === email)
            return Promise.resolve(this);
        await this.client.requests.put(endpoints_1.default.account.email, { email, password });
        this.email = email;
        return this;
    }
    /**
     * Updates the password for the account.
     * Note: the password is **not** stored in the account instance.
     * @param oldPass The account's current password.
     * @param newPass The new password for the account.
     * @returns The updated account instance (no change).
     */
    async updatePassword(oldPass, newPass) {
        if (oldPass === newPass)
            return Promise.resolve(this);
        await this.client.requests.put(endpoints_1.default.account.password, {
            current_password: oldPass,
            password: newPass,
            password_confirmation: newPass
        });
        return this;
    }
    /**
     * Fetches the 2FA image URL code.
     * @returns The two-factor image URL code.
     */
    async get2FACode() {
        const data = await this.client.requests.get(endpoints_1.default.account.tfa);
        return data.data.image_url_data;
    }
    /**
     * Enables 2FA for the account.
     * @param code The 2FA code.
     * @returns A list of 2FA codes.
     */
    async enable2FA(code) {
        const data = await this.client.requests.post(endpoints_1.default.account.tfa, { code });
        this.tokens.push(...data.attributes.tokens);
        return this.tokens;
    }
    /**
     * Disables 2FA on the account and removes existing authentication tokens.
     * @param password The account password.
     */
    async disable2FA(password) {
        await this.client.requests.delete(endpoints_1.default.account.tfa, { password });
        this.tokens = [];
    }
    /** @returns A list of API keys associated with the account. */
    async fetchKeys() {
        const data = await this.client.requests.get(endpoints_1.default.account.apikeys.main);
        this.apikeys = data.data.map((o) => {
            let k = caseConv_1.default.toCamelCase(o.attributes);
            k.createdAt = new Date(k.createdAt);
            k.lastUsedAt &&= new Date(k.lastUsedAt);
            return k;
        });
        return this.apikeys;
    }
    /**
     * Creates an API key associated with the account.
     * @param description The description (or memo) for the key.
     * @param allowedIps A list of IP addresses that can use this key.
     * @returns The new API key.
     */
    async createKey(description, allowedIps = []) {
        const data = await this.client.requests.post(endpoints_1.default.account.apikeys.main, { description, allowed_ips: allowedIps });
        const key = caseConv_1.default.toCamelCase(data.attributes);
        key.createdAt = new Date(key.createdAt);
        key.lastUsedAt &&= new Date(key.lastUsedAt);
        key.token = data.meta.secret_token;
        this.apikeys.push(key);
        return key;
    }
    /**
     * Deletes an API key from the account.
     * @param id The identifier of the key.
     */
    async deleteKey(id) {
        await this.client.requests.delete(endpoints_1.default.account.apikeys.get(id));
        this.apikeys = this.apikeys.filter(k => k.identifier !== id);
    }
    /** @returns A list of activity logs on the account. */
    async fetchActivities() {
        const data = await this.client.requests.get(endpoints_1.default.account.activity);
        const act = data.data.map((o) => {
            const a = caseConv_1.default.toCamelCase(o.attributes);
            a.timestamp = new Date(a.timestamp);
            return a;
        });
        return act;
    }
    /** @returns A list of SSH keys associated with the account. */
    async fetchSSHKeys() {
        const data = await this.client.requests.get(endpoints_1.default.account.sshkeys.main);
        const keys = data.data.map((o) => {
            const k = caseConv_1.default.toCamelCase(o.attributes);
            k.createdAt = new Date(k.createdAt);
            return k;
        });
        return keys;
    }
    /**
     * Creates an SSH key associated with the account.
     * @param name The name of the key.
     * @param publicKey The public key to authorize.
     * @returns The new SSH key.
     */
    async createSSHKey(name, publicKey) {
        const data = await this.client.requests.post(endpoints_1.default.account.sshkeys.main, { name, public_key: publicKey });
        const key = caseConv_1.default.toCamelCase(data.attributes);
        key.createdAt = new Date(key.createdAt);
        return key;
    }
    /**
     * Removes an SSH key from the account.
     * @param fingerprint The fingerprint of the SSH key.
     */
    async removeSSHKey(fingerprint) {
        await this.client.requests.post(endpoints_1.default.account.sshkeys.remove, { fingerprint });
    }
}
exports.Account = Account;
