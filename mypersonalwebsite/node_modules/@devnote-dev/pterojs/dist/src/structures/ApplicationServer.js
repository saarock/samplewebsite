"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationServer = void 0;
const ApplicationDatabaseManager_1 = require("../application/ApplicationDatabaseManager");
const caseConv_1 = require("../util/caseConv");
class ApplicationServer {
    constructor(client, data) {
        this.client = client;
        this.databases = new ApplicationDatabaseManager_1.ApplicationDatabaseManager(client, data.id);
        this.id = data.id;
        this.uuid = data.uuid;
        this.identifier = data.identifier;
        this.createdAt = new Date(data.created_at);
        this.createdTimestamp = this.createdAt.getTime();
        this._patch(data);
    }
    _patch(data) {
        if ('external_id' in data)
            this.externalId = data.external_id;
        if ('name' in data)
            this.name = data.name;
        if ('description' in data)
            this.description = data.description || undefined;
        if ('status' in data)
            this.status = data.status;
        if ('suspended' in data)
            this.suspended = data.suspended;
        if ('limits' in data)
            this.limits = caseConv_1.default.toCamelCase(data.limits);
        if ('feature_limits' in data)
            this.featureLimits = data.feature_limits;
        if ('user' in data)
            this.ownerId = data.user;
        if ('node' in data)
            this.nodeId = data.node;
        if ('allocation' in data)
            this.allocation = data.allocation;
        if ('nest' in data)
            this.nest = data.nest;
        if ('egg' in data)
            this.egg = data.egg;
        if ('container' in data) {
            this.container = caseConv_1.default.toCamelCase(data.container, { ignore: ['environment'] });
            this.container.environment = data.container.environment;
            this.container.installed = !!this.container.installed;
        }
        if ('relationships' in data) {
            this.owner = 'user' in data.relationships
                ? this.client.users.resolve(data)
                : undefined;
            this.node = 'node' in data.relationships
                ? this.client.nodes.resolve(data)
                : undefined;
        }
    }
    /**
     * Returns a formatted URL to the server.
     * @returns The formatted URL.
     */
    get panelURL() {
        return `${this.client.domain}/server/${this.identifier}`;
    }
    /**
     * Returns a formatted URL to the server in the admin panel.
     * @returns The formatted URL.
     */
    get adminURL() {
        return `${this.client.domain}/admin/servers/view/${this.id}`;
    }
    /**
     * Fetches the User object of the server owner.
     * The user can be accessed via {@link ApplicationServer.owner}.
     * @returns The fetched user.
     */
    async fetchOwner() {
        if (this.owner)
            return this.owner;
        const user = await this.client.users.fetch(this.ownerId, { force: true });
        this.owner = user;
        return user;
    }
    /**
     * Updates the details of the server.
     * @param options Update details options.
     * @see {@link UpdateDetailsOptions}.
     * @returns The updated instance.
     */
    async updateDetails(options) {
        const data = await this.client.servers.updateDetails(this.id, options);
        this._patch(data.toJSON());
        return this;
    }
    /**
     * Updates the build configuration of the server.
     * @param options Update build options.
     * @returns The updated instance.
     */
    async updateBuild(options) {
        const data = await this.client.servers.updateBuild(this.id, options);
        this._patch(data);
        return this;
    }
    /**
     * Updates the startup configuration of the server.
     * @param options Update startup options.
     * @see {@link UpdateStartupOptions}.
     * @returns The updated instance.
     */
    async updateStartup(options) {
        const data = await this.client.servers.updateStartup(this.id, options);
        this._patch(data);
        return this;
    }
    /** Suspends the server. */
    async suspend() {
        await this.client.servers.suspend(this.id);
    }
    /** Unsuspends the server. */
    async unsuspend() {
        await this.client.servers.unsuspend(this.id);
    }
    /**
     * Triggers the reinstall process for the server.
     * Note: most endpoints will be unavailable until this is complete.
     */
    async reinstall() {
        await this.client.servers.reinstall(this.id);
    }
    /**
     * Converts the server into a JSON object, relative to the API
     * response object.
     * @returns The JSON object.
     */
    toJSON() {
        return caseConv_1.default.toSnakeCase(this, {
            ignore: ['client', 'user', 'node'],
            map: { ownerId: 'user', nodeId: 'node' }
        });
    }
    /** @returns The string representation of the server. */
    toString() {
        return this.name;
    }
}
exports.ApplicationServer = ApplicationServer;
