"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dict = void 0;
/**
 * Dict (or Dictionary) is an extended Map with additional helper methods
 * used for manager caches in the PteroJS library.
 */
class Dict extends Map {
    constructor() {
        super(...arguments);
        this._limit = 0;
    }
    get limit() {
        return this._limit;
    }
    /**
     * Sets a limit for the number of entries the dict can have.
     * **Note:** this cannot be changed once set. Attempting to will throw an error.
     * @param amount The number of entries allowed for the dict.
     */
    setLimit(amount) {
        if (this._limit)
            throw new Error('Cannot override a set limit.');
        this._limit = amount < 0 ? 0 : amount;
    }
    /** @returns Whether the dict has a set limit. */
    isLimited() {
        return !!this._limit && super.size === this._limit;
    }
    set(key, value) {
        if (this.isLimited())
            throw new Error(`Dict has reached its limit (${this._limit})`);
        return super.set(key, value);
    }
    /**
     * Checks if at least one of the entries in the dict pass the function.
     * @param fn The function to apply to the dict.
     */
    some(fn) {
        for (const [k, v] of this)
            if (fn(v, k, this))
                return true;
        return false;
    }
    /**
     * Checks if all the entries in the dict pass the function.
     * @param fn The function to apply to the dict.
     */
    every(fn) {
        for (const [k, v] of this)
            if (!fn(v, k, this))
                return false;
        return true;
    }
    /**
     * Checks that any of the specified keys exist in the dict.
     * @param keys The keys to check for.
     */
    hasAny(...keys) {
        return keys.some(k => super.has(k));
    }
    /**
     * Checks that all of the specified keys exist in the dict.
     * @param keys The keys to check for.
     */
    hasAll(...keys) {
        return keys.every(k => super.has(k));
    }
    /**
     * Returns the first entry (or entries if otherwise specified) in the dict.
     * @param [amount] The number of entries to return from the start of the dict.
     */
    first(amount) {
        const v = [...super.values()];
        if (amount === undefined)
            return v[0];
        const s = v.splice(0, amount);
        return s.length === 1 ? s[0] : s;
    }
    /**
     * Returns the first key (or keys if otherwise specified) in the dict.
     * @param [amount] The number of keys to return from the start of the dict.
     */
    firstKey(amount) {
        const k = [...super.keys()];
        if (amount === undefined)
            return k[0];
        const s = k.splice(0, amount);
        return s.length === 1 ? s[0] : s;
    }
    /**
     * Returns the last entry (or entries if otherwise specified) in the dict.
     * @param [amount] The number of entries to return from the end of the dict.
     */
    last(amount) {
        const v = [...super.values()];
        if (amount === undefined)
            return v[v.length - 1];
        const s = v.slice(-amount);
        return s.length === 1 ? s[0] : s;
    }
    /**
     * Returns the last key (or keys if otherwise specified) in the dict.
     * @param [amount] The number of keys to return from the end of the dict.
     */
    lastKey(amount) {
        const k = [...super.keys()];
        if (amount === undefined)
            return k[k.length - 1];
        const s = k.slice(-amount);
        return s.length === 1 ? s[0] : s;
    }
    /**
     * Returns a random entry (or entries if otherwise specified) in the dict.
     * @param [amount] The number of entries to return from the dict.
     */
    random(amount) {
        const v = [...super.values()];
        if (amount === undefined)
            return v[Math.floor(Math.random() * v.length)];
        const s = [];
        for (let i = 0; i < amount; i++)
            s.push(v[Math.floor(Math.random() * v.length)]);
        return s.length === 1 ? s[0] : s;
    }
    /**
     * Returns a random key (or keys if otherwise specified) in the dict.
     * @param [amount] The number of keys to return from the dict.
     */
    randomKey(amount) {
        const k = [...super.keys()];
        if (amount === undefined)
            return k[Math.floor(Math.random() * k.length)];
        const s = [];
        for (let i = 0; i < amount; i++)
            s.push(k[Math.floor(Math.random() * k.length)]);
        return s.length === 1 ? s[0] : s;
    }
    /**
     * Applies the function to each entry in the dict and returns an array of
     * the results.
     * @param fn The function to apply to the dict.
     * @returns The mapped results.
     */
    map(fn) {
        const res = [];
        for (const [k, v] of this)
            res.push(fn(v, k, this));
        return res;
    }
    filter(fn) {
        const res = new Dict();
        for (const [k, v] of this)
            if (fn(v, k, this))
                res.set(k, v);
        return res;
    }
    find(fn) {
        for (const [k, v] of this)
            if (fn(v, k, this))
                return v;
        return undefined;
    }
    /**
     * Applies a function to each entry in the dict and returns the number of
     * items removed.
     * @param fn The function to apply to the dict.
     * @returns The number of sweeped entries.
     */
    sweep(fn) {
        let res = 0;
        for (const [k, v] of this)
            if (fn(v, k, this))
                super.delete(k) && res++;
        return res;
    }
    /**
     * Applies a function to each entry in the dict and returns 2 dicts, the first
     * containing entries that passed the function and the second containing
     * the failed entries.
     * @param fn The function to apply to the dict.
     * @returns The passed and failed dicts.
     */
    part(fn) {
        const pass = new Dict();
        const fail = new Dict();
        for (const [k, v] of this)
            if (fn(v, k, this))
                pass.set(k, v);
            else
                fail.set(k, v);
        return [pass, fail];
    }
    /**
     * Reduces each entry in the dict to a single value.
     * @param fn The function to apply to the dict.
     * @returns The reduced value.
     */
    reduce(fn, acc) {
        for (const [k, v] of this)
            acc = fn(v, k, this);
        return acc;
    }
    join(...dict) {
        const res = this.clone();
        for (const d of dict)
            for (const [k, v] of d)
                res.set(k, v);
        return res;
    }
    /**
     * @param dict The dict to compare differences to.
     * @returns A dict containing the different entries between both dicts.
     */
    difference(dict) {
        const res = new Dict();
        for (const [k, v] of this)
            if (!dict.has(k))
                res.set(k, v);
        for (const [k, v] of dict)
            if (!super.has(k))
                res.set(k, v);
        return res;
    }
    /**
     * Updates the values of the current dict with the specified dict, settings the
     * values in place.
     * @param dict The dict to update with.
     */
    update(dict) {
        for (const [k, v] of dict)
            this.set(k, v);
    }
    /** @returns A clone of the dict. */
    clone() {
        return new Dict(super.entries());
    }
}
exports.Dict = Dict;
