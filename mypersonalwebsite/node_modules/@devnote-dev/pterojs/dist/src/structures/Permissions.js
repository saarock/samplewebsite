"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Permissions = exports.Flags = void 0;
/**
 * Represents all the Pterodactyl server permissions as flags.
 */
var Flags;
(function (Flags) {
    Flags["WEBSOCKET_CONNECT"] = "websocket.connect";
    Flags["CONTROL_CONSOLE"] = "control.console";
    Flags["CONTROL_START"] = "control.start";
    Flags["CONTROL_STOP"] = "control.stop";
    Flags["CONTROL_RESTART"] = "control.restart";
    Flags["USER_CREATE"] = "user.create";
    Flags["USER_READ"] = "user.read";
    Flags["USER_UPDATE"] = "user.update";
    Flags["USER_DELETE"] = "user.delete";
    Flags["FILE_CREATE"] = "file.create";
    Flags["FILE_READ"] = "file.read";
    Flags["FILE_READ_CONTENT"] = "file.read-content";
    Flags["FILE_UPDATE"] = "file.update";
    Flags["FILE_DELETE"] = "file.delete";
    Flags["FILE_ARCHIVE"] = "file.archive";
    Flags["FILE_SFTP"] = "file.sftp";
    Flags["BACKUP_CREATE"] = "backup.create";
    Flags["BACKUP_READ"] = "backup.read";
    Flags["BACKUP_UPDATE"] = "backup.update";
    Flags["BACKUP_DELETE"] = "backup.delete";
    Flags["ALLOCATION_READ"] = "allocation.read";
    Flags["ALLOCATION_CREATE"] = "allocation.create";
    Flags["ALLOCATION_UPDATE"] = "allocation.update";
    Flags["ALLOCATION_DELETE"] = "allocation.delete";
    Flags["STARTUP_READ"] = "startup.read";
    Flags["STARTUP_UPDATE"] = "startup.update";
    Flags["DATABASE_CREATE"] = "database.create";
    Flags["DATABASE_READ"] = "database.read";
    Flags["DATABASE_UPDATE"] = "database.update";
    Flags["DATABASE_DELETE"] = "database.delete";
    Flags["DATABASE_VIEW_PASSWORD"] = "database.view_password";
    Flags["SCHEDULE_CREATE"] = "schedule.create";
    Flags["SCHEDULE_READ"] = "schedule.read";
    Flags["SCHEDULE_UPDATE"] = "schedule.update";
    Flags["SCHEDULE_DELETE"] = "schedule.delete";
    Flags["SETTINGS_RENAME"] = "settings.rename";
    Flags["SETTINGS_REINSTALL"] = "settings.reinstall";
    Flags["ADMIN_WEBSOCKET_ERRORS"] = "admin.websocket.errors";
    Flags["ADMIN_WEBSOCKET_INSTALL"] = "admin.websocket.install";
    Flags["ADMIN_WEBSOCKET_TRANSFER"] = "admin.websocket.transfer";
})(Flags = exports.Flags || (exports.Flags = {}));
class Permissions {
    /**
     * @param perms The data to resolve permissions from.
     */
    constructor(...perms) {
        this.value = Permissions.resolve(...perms);
    }
    /** @returns All the server control permissions. */
    static get CONTROL() {
        return Object.freeze([
            Flags.CONTROL_CONSOLE,
            Flags.CONTROL_START,
            Flags.CONTROL_STOP,
            Flags.CONTROL_RESTART
        ]);
    }
    /** @returns All of the user/subuser permissions. */
    static get USERS() {
        return Object.freeze([
            Flags.USER_CREATE,
            Flags.USER_READ,
            Flags.USER_UPDATE,
            Flags.USER_DELETE
        ]);
    }
    /** @returns All of the server file permissions. */
    static get FILES() {
        return Object.freeze([
            Flags.FILE_CREATE,
            Flags.FILE_READ,
            Flags.FILE_READ_CONTENT,
            Flags.FILE_UPDATE,
            Flags.FILE_DELETE,
            Flags.FILE_ARCHIVE,
            Flags.FILE_SFTP
        ]);
    }
    /** @returns All the server backup permissions. */
    static get BACKUPS() {
        return Object.freeze([
            Flags.BACKUP_CREATE,
            Flags.BACKUP_READ,
            Flags.BACKUP_UPDATE,
            Flags.BACKUP_DELETE
        ]);
    }
    /** @returns All the server allocation permissions. */
    static get ALLOCATIONS() {
        return Object.freeze([
            Flags.ALLOCATION_READ,
            Flags.ALLOCATION_CREATE,
            Flags.ALLOCATION_UPDATE,
            Flags.ALLOCATION_DELETE
        ]);
    }
    /** @returns All the server startup permissions. */
    static get STARTUPS() {
        return Object.freeze([
            Flags.STARTUP_READ,
            Flags.STARTUP_UPDATE
        ]);
    }
    /** @returns All the server database permissions. */
    static get DATABASES() {
        return Object.freeze([
            Flags.DATABASE_CREATE,
            Flags.DATABASE_READ,
            Flags.DATABASE_UPDATE,
            Flags.DATABASE_DELETE,
            Flags.DATABASE_VIEW_PASSWORD
        ]);
    }
    /** @returns All the server schedule permissions. */
    static get SCHEDULES() {
        return Object.freeze([
            Flags.SCHEDULE_CREATE,
            Flags.SCHEDULE_READ,
            Flags.SCHEDULE_UPDATE,
            Flags.SCHEDULE_DELETE
        ]);
    }
    /** @returns All the server settings permissions. */
    static get SETTINGS() {
        return Object.freeze([
            Flags.SETTINGS_RENAME,
            Flags.SETTINGS_REINSTALL
        ]);
    }
    /** @returns The admin permissions. */
    static get ADMIN() {
        return Object.freeze([
            Flags.ADMIN_WEBSOCKET_ERRORS,
            Flags.ADMIN_WEBSOCKET_INSTALL,
            Flags.ADMIN_WEBSOCKET_TRANSFER
        ]);
    }
    /**
     * Resolves a permissions object from a specified source.
     * @param perms The permissions to resolve.
     * @returns The resolved permissions.
     */
    static resolve(...perms) {
        const res = [];
        const values = Object.values(Flags);
        if (perms.some(p => p === '*'))
            return values;
        for (const p of perms) {
            if (p in Flags || values.includes(p)) {
                res.push(p);
            }
            else {
                throw new Error(`unknown permission '${p}'`);
            }
        }
        return res;
    }
    /**
     * @param perms The permissions to check for.
     * @returns True if the current value has any of the specified permissions.
     */
    hasAny(...perms) {
        const res = Permissions.resolve(...perms);
        return res.some(p => this.value.includes(p));
    }
    /**
     * @param perms The permissions to check for.
     * @returns True if the current value has all of the specified permissions.
     */
    hasAll(...perms) {
        const res = Permissions.resolve(...perms);
        return res.every(p => this.value.includes(p));
    }
    /**
     * @returns True if the current value includes administrative permissions.
     */
    isAdmin() {
        return this.value.some((p) => [
            Flags.ADMIN_WEBSOCKET_ERRORS,
            Flags.ADMIN_WEBSOCKET_INSTALL,
            Flags.ADMIN_WEBSOCKET_TRANSFER
        ].includes(p));
    }
    /**
     * Adds the specified permissions to the current value.
     * @param perms The permissions to add.
     * @returns The updated permissions instance.
     */
    add(...perms) {
        this.value = this.value.concat(Permissions.resolve(...perms));
        return this;
    }
    /**
     * Removes the specified permissions from the current value.
     * @param perms The permissions to remove.
     * @returns The updated permissions instance.
     */
    remove(...perms) {
        const res = Permissions.resolve(...perms);
        this.value = this.value.filter(p => !res.includes(p));
        return this;
    }
    /**
     * @returns An object with all the permissions having `true` or `false`
     * values if they are currently present.
     */
    serialize() {
        const res = {};
        for (let [k, v] of Object.entries(Flags))
            res[k] = this.value.includes(v);
        return res;
    }
}
exports.Permissions = Permissions;
