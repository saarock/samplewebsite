"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientDatabaseManager = void 0;
const BaseManager_1 = require("../structures/BaseManager");
const Dict_1 = require("../structures/Dict");
const caseConv_1 = require("../util/caseConv");
const endpoints_1 = require("./endpoints");
class ClientDatabaseManager extends BaseManager_1.BaseManager {
    constructor(client, serverId) {
        super();
        this.client = client;
        this.cache = new Dict_1.Dict();
        this.serverId = serverId;
    }
    /** Allowed filter arguments for databases (none). */
    get FILTERS() { return Object.freeze([]); }
    /**
     * Allowed include arguments for databases:
     * * password
     */
    get INCLUDES() {
        return Object.freeze(['password']);
    }
    /** Allowed sort arguments for databases (none). */
    get SORTS() { return Object.freeze([]); }
    /**
     * Transforms the raw database object(s) into typed objects.
     * @param data The resolvable database object(s).
     * @returns The resolved database object(s).
     */
    _patch(data) {
        if (data.data) {
            const res = new Dict_1.Dict();
            for (let o of data.data) {
                const d = caseConv_1.default.toCamelCase(o.attributes);
                res.set(d.id, d);
            }
            this.cache.update(res);
            return res;
        }
        const d = caseConv_1.default.toCamelCase(data.attributes);
        this.cache.set(d.id, d);
        return d;
    }
    /**
     * Fetches a list of databases from the API with the given options (default is undefined).
     *
     * @param [options] Additional fetch options.
     * @returns The fetched databases.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.databases.fetch({ page: 2 })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async fetch(options = {}) {
        const data = await this.client.requests.get(endpoints_1.default.servers.databases.main(this.serverId), options, null, this);
        return this._patch(data);
    }
    /**
     * Creates a database on the server.
     * @param database The name of the database.
     * @param remote The connections allowed to the database.
     * @returns The new database.
     */
    async create(database, remote) {
        const data = await this.client.requests.post(endpoints_1.default.servers.databases.main(this.serverId), { database, remote });
        return this._patch(data);
    }
    /**
     * Rotates the password of a specified database.
     * @param id The ID of the database.
     * @returns The updated database.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.databases.rotate(1)
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async rotate(id) {
        const data = await this.client.requests.post(endpoints_1.default.servers.databases.rotate(this.serverId, id));
        return this._patch(data);
    }
    /**
     * Deletes a database from the server.
     * @param id The ID of the database.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.databases.delete(2).catch(console.error);
     * ```
     */
    async delete(id) {
        await this.client.requests.delete(endpoints_1.default.servers.databases.get(this.serverId, id));
        this.cache.delete(id);
    }
}
exports.ClientDatabaseManager = ClientDatabaseManager;
