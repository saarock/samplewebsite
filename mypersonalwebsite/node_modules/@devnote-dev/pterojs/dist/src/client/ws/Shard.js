"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Shard = void 0;
const events_1 = require("events");
const ws_1 = require("ws");
const Errors_1 = require("../../structures/Errors");
const client_1 = require("../../common/client");
const endpoints_1 = require("../endpoints");
const packetHandler_1 = require("./packetHandler");
class Shard extends events_1.EventEmitter {
    constructor(client, id, origin) {
        super();
        this.client = client;
        this.id = id;
        this.origin = origin;
        this.socket = null;
        this.status = client_1.ShardStatus.CLOSED;
        this.readyAt = 0;
        this.ping = -1;
        this.lastPing = 0;
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    on(event, listener) {
        super.on(event, listener);
        return this;
    }
    once(event, listener) {
        super.once(event, listener);
        return this;
    }
    off(event, listener) {
        super.off(event, listener);
        return this;
    }
    debug(message) {
        super.emit('debug', `[Shard ${this.id}] ${message}`);
    }
    /** Initializes the connection to the server websocket after authentication. */
    async connect() {
        if (![0, 1].includes(this.status))
            return;
        this.status = client_1.ShardStatus.CONNECTING;
        const auth = await this.client.requests.get(endpoints_1.default.servers.ws(this.id));
        const origin = this.origin ? { origin: this.client.domain } : undefined;
        this.socket = new ws_1.WebSocket(auth.data.socket, origin);
        this.socket.on('open', () => this.onOpen(auth.data.token));
        this.socket.on('message', m => this.onMessage(m.toString()));
        this.socket.on('error', e => this.onError(e));
        this.socket.on('close', () => this.onClose());
    }
    async refresh() {
        if (this.status !== client_1.ShardStatus.CONNECTED)
            throw new Error('Shard is not connected.');
        const auth = await this.client.requests.get(endpoints_1.default.servers.ws(this.id));
        this.send('auth', [auth.data.token]);
    }
    /**
     * Sends a websocket event to the server (with optional payload args).
     * @param event The event to send to the server.
     * @param args Additional arguements to pass with to the event.
     * @example
     * ```
     * const shard = client.addSocketServer('411d2eb9');
     * shard.on('authSuccess', () => shard.send('send logs'));
     * shard.connect();
     * ```
     */
    send(event, args = []) {
        if (!this.socket)
            throw new Error('Socket for this shard is unavailable.');
        this.debug(`sending event '${event}'`);
        this.socket.send(JSON.stringify({ event, args }));
    }
    async request(event, args = '') {
        switch (event) {
            case 'auth': {
                this.send('auth', [args]);
                return new Promise(res => this.once('authSuccess', res));
            }
            case 'sendCommand': {
                this.send('send command', [args]);
                // unsafe to return response
                return Promise.resolve();
            }
            case 'sendLogs': {
                this.send('send logs');
                return new Promise(res => this.once('serverOutput', res));
            }
            case 'sendStats': {
                this.send('send stats');
                return new Promise(res => this.once('statsUpdate', res));
            }
            case 'setState': {
                this.send('set state', [args]);
                return new Promise(res => this.once('statusUpdate', res));
            }
            default:
                throw new Errors_1.WebSocketError('Invalid sendable websocket event');
        }
    }
    /** Disconnects the websocket from the API. */
    disconnect() {
        this.socket?.close(1000);
        this.socket = null;
        this.readyAt = 0;
        this.ping = -1;
        this.lastPing = -1;
    }
    onOpen(token) {
        this.status = client_1.ShardStatus.CONNECTED;
        this.readyAt = Date.now();
        this.send('auth', [token]);
        this.debug('connection opened');
        super.emit('serverConnect', this.id);
        process.on('SIGINT', () => this.disconnect());
        process.on('SIGTERM', () => this.disconnect());
    }
    async onMessage(packet) {
        if (!packet)
            return this.debug('received a malformed packet');
        const data = JSON.parse(packet);
        super.emit('rawPayload', data);
        switch (data.event) {
            case 'auth success':
                this.ping = Date.now() - this.lastPing;
                this.lastPing = Date.now();
                super.emit('authSuccess');
                break;
            case 'token expiring':
                this.debug('refreshing token');
                await this.refresh();
                break;
            case 'token expired':
                this.disconnect();
                break;
            default:
                (0, packetHandler_1.default)(this, data);
                break;
        }
    }
    onError(err) {
        this.debug(`received an error: ${err.message}`);
    }
    onClose() {
        this.status = client_1.ShardStatus.CLOSED;
        this.debug('connection closed');
        super.emit('serverDisconnect');
    }
}
exports.Shard = Shard;
