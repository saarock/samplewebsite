"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackupManager = void 0;
const fs_1 = require("fs");
const BaseManager_1 = require("../structures/BaseManager");
const Dict_1 = require("../structures/Dict");
const Errors_1 = require("../structures/Errors");
const caseConv_1 = require("../util/caseConv");
const endpoints_1 = require("./endpoints");
class BackupManager extends BaseManager_1.BaseManager {
    constructor(client, serverId) {
        super();
        this.client = client;
        this.cache = new Dict_1.Dict();
        this.serverId = serverId;
    }
    /** Allowed filter arguments for backups (none). */
    get FILTERS() { return Object.freeze([]); }
    /** Allowed include arguments for backups (none). */
    get INCLUDES() {
        return Object.freeze([]);
    }
    /** Allowed sort arguments for backups (none). */
    get SORTS() { return Object.freeze([]); }
    /**
     * Transforms the raw backup object(s) into typed objects.
     * @param data The resolvable backup object(s).
     * @returns The resolved backup object(s).
     */
    _patch(data) {
        if (data.data) {
            const res = new Dict_1.Dict();
            for (let o of data.data) {
                const b = caseConv_1.default.toCamelCase(o.attributes, {
                    map: {
                        is_successful: 'successful',
                        is_locked: 'locked'
                    }
                });
                b.createdAt = new Date(b.createdAt);
                b.completedAt &&= new Date(b.completedAt);
                res.set(b.uuid, b);
            }
            this.cache.update(res);
            return res;
        }
        const b = caseConv_1.default.toCamelCase(data.attributes, {
            map: {
                is_successful: 'successful',
                is_locked: 'locked'
            }
        });
        b.createdAt = new Date(b.createdAt);
        b.completedAt &&= new Date(b.completedAt);
        this.cache.set(b.uuid, b);
        return b;
    }
    async fetch(op, ops = {}) {
        let path = endpoints_1.default.servers.backups.main(this.serverId);
        if (typeof op === 'string') {
            if (!ops.force && this.cache.has(op))
                return this.cache.get(op);
            path = endpoints_1.default.servers.backups.get(this.serverId, op);
        }
        else {
            if (op)
                ops = op;
        }
        const data = await this.client.requests.get(path, ops, null, this);
        return this._patch(data);
    }
    /**
     * Creates a new backup on the server.
     * @see {@link CreateBackupOptions}.
     *
     * @param options Create backup options.
     * @returns The new backup.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.create({ name: 'bungee-archive' })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async create(options = {}) {
        const data = await this.client.requests.post(endpoints_1.default.servers.backups.main(this.serverId), options);
        return this._patch(data);
    }
    /**
     * Toggles the locked status of a backup.
     * @param id The UUID of the backup.
     * @returns The updated backup.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.toggleLock('904df120')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async toggleLock(id) {
        const data = await this.client.requests.post(endpoints_1.default.servers.backups.lock(this.serverId, id));
        return this._patch(data);
    }
    /**
     * Fetches the download URL for a specified backup.
     * @param id The UUID of the backup.
     * @returns The download URL.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.getDownloadURL('904df120')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async getDownloadURL(id) {
        const data = await this.client.requests.get(endpoints_1.default.servers.backups.download(this.serverId, id));
        return data.attributes.url;
    }
    /**
     * Fetches and saves a backup to a specified path on the system.
     * @param id The UUID of the backup.
     * @param dest The file path to save the backup to.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.download('904df120', './bungee-archive.tar.gz')
     *  .catch(console.error);
     * ```
     */
    async download(id, dest) {
        if ((0, fs_1.existsSync)(dest))
            throw new Errors_1.ValidationError('A file or directory exists at this path.');
        const url = await this.getDownloadURL(id);
        const data = await this.client.requests.raw('GET', url);
        (0, fs_1.writeFileSync)(dest, data.toString(), { encoding: 'utf-8' });
    }
    /**
     * Restores a specified backup to the server.
     * @param id The UUID of the backup.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.restore('904df120').catch(console.error);
     * ```
     */
    async restore(id) {
        await this.client.requests.post(endpoints_1.default.servers.backups.restore(this.serverId, id));
    }
    /**
     * Deletes a specified backup.
     * @param id The UUID of the backup.
     * @example
     * ```
     * const server = await client.servers.fetch('34740510');
     * await server.backups.delete('c4b9c4c7').catch(console.error);
     * ```
     */
    async delete(id) {
        await this.client.requests.delete(endpoints_1.default.servers.backups.get(this.serverId, id));
        this.cache.delete(id);
    }
}
exports.BackupManager = BackupManager;
