"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientServerManager = void 0;
const BaseManager_1 = require("../structures/BaseManager");
const ClientServer_1 = require("../structures/ClientServer");
const Dict_1 = require("../structures/Dict");
const Errors_1 = require("../structures/Errors");
const caseConv_1 = require("../util/caseConv");
const endpoints_1 = require("./endpoints");
class ClientServerManager extends BaseManager_1.BaseManager {
    constructor(client) {
        super();
        this.client = client;
        this.cache = new Dict_1.Dict();
        this.meta = undefined;
    }
    /** Allowed filter arguments for servers (none). */
    get FILTERS() { return Object.freeze([]); }
    /**
     * Allowed include arguments for servers:
     * * egg
     * * subusers
     */
    get INCLUDES() {
        return Object.freeze(['egg', 'subusers']);
    }
    /** Allowed sort arguments for servers (none). */
    get SORTS() { return Object.freeze([]); }
    /**
     * Transforms the raw server object(s) into class objects.
     * @param data The resolvable server object(s).
     * @returns The resolved server object(s).
     */
    _patch(data) {
        if (data.meta)
            this.meta = caseConv_1.default.toCamelCase(data.meta);
        if (data?.data) {
            const res = new Dict_1.Dict();
            for (let o of data.data) {
                const s = new ClientServer_1.ClientServer(this.client, o.attributes);
                res.set(s.identifier, s);
            }
            if (this.client.options.servers.cache)
                this.cache.update(res);
            return res;
        }
        const s = new ClientServer_1.ClientServer(this.client, data.attributes);
        if (this.client.options.servers.cache)
            this.cache.set(s.identifier, s);
        return s;
    }
    /**
     * @param id The ID of the server.
     * @returns The formatted URL to the server.
     */
    panelURLFor(id) {
        return `${this.client.domain}/server/${id}`;
    }
    async fetch(op, ops = {}) {
        let path = endpoints_1.default.servers.main;
        if (typeof op === 'string') {
            if (!ops.force && this.cache.has(op))
                return this.cache.get(op);
            path = endpoints_1.default.servers.get(op);
        }
        else {
            if (op)
                ops = op;
        }
        const data = await this.client.requests.get(path, ops, null, this);
        return this._patch(data);
    }
    /**
     * Fetches the server resources data of a server.
     * @param id The identifier of the server.
     * @returns The server resources.
     * @example
     * ```
     * client.servers.fetchResources('411d2eb9')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async fetchResources(id) {
        const data = await this.client.requests.get(endpoints_1.default.servers.resources(id));
        return caseConv_1.default.toCamelCase(data.attributes);
    }
    /**
     * Fetches the server startup and egg variables data.
     * @see {@link StartupData}.
     *
     * @param id The identifier of the server.
     * @returns The startup and egg variable data.
     * @example
     * ```
     * client.servers.fetchStartup('411d2eb9')
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async fetchStartup(id) {
        const data = await this.client.requests.get(endpoints_1.default.servers.startup.get(id));
        const parsed = caseConv_1.default.toCamelCase(data.meta);
        parsed.variables = data.data.map((v) => caseConv_1.default.toCamelCase(v.attributes));
        return parsed;
    }
    /**
     * Sends a command to the console of a server. Note that this does not return the output from
     * the command, see {@link WebSocketManager} for more information.
     * @param id The identifier of the server.
     * @param command The command to send.
     * @example
     * ```
     * client.servers.sendCommand('411d2eb9', '/say "hello world"')
     *  .catch(console.error);
     * ```
     */
    async sendCommand(id, command) {
        await this.client.requests.post(endpoints_1.default.servers.command(id), { command });
    }
    /**
     * Sets the power state of a server.
     * @param id The identifier of the server.
     * @param state The power state to set.
     * @example
     * ```
     * client.servers.setPowerState('411d2eb9', 'start')
     *  .catch(console.error);
     * ```
     */
    async setPowerState(id, state) {
        if (!['start', 'stop', 'restart', 'kill'].includes(state))
            throw new Errors_1.ValidationError('Invalid power state, must be: start, stop, restart, or kill.');
        await this.client.requests.post(endpoints_1.default.servers.power(id), { signal: state });
    }
    /**
     * Updates the docker image of a server.
     * @param id The identifier of the server.
     * @param image The docker image.
     * @example
     * ```
     * client.servers.setDockerImage(
     *  '411d2eb9',
     *  'ghcr.io/pterodactyl/yolks:java_17'
     *  )
     *  .catch(console.error);
     * ```
     */
    async setDockerImage(id, image) {
        await this.client.requests.put(endpoints_1.default.servers.settings.image(id), { docker_image: image });
    }
    /**
     * Updates a specified environment variable on a server. The key must be
     * the environment variable name in capital letters, not the normal
     * variable name.
     * @param id The identifier of the server.
     * @param key The environment variable key.
     * @param value The value of the environment variable.
     * @returns The updated egg variable.
     * @example
     * ```
     * await client.servers
     *     .setVariable('b8f32a45', 'SERVER_JARFILE', 'latest.jar')
     *     .then(console.log);
     * ```
     */
    async setVariable(id, key, value) {
        if (typeof key !== 'string')
            throw new Errors_1.ValidationError('variable key', 'string', typeof key);
        if (typeof value !== 'string')
            throw new Errors_1.ValidationError('variable value', 'string', typeof value);
        const data = await this.client.requests.put(endpoints_1.default.servers.startup.var(id), { key, value });
        return caseConv_1.default.toCamelCase(data.attributes);
    }
    /**
     * Updates the name of a server.
     * @param id The identifier of the server.
     * @param name The new server name.
     * @example
     * ```
     * client.servers.rename('411d2eb9', 'mc-03')
     *  .catch(console.error);
     * ```
     */
    async rename(id, name) {
        await this.client.requests.post(endpoints_1.default.servers.settings.rename(id), { name });
        if (this.cache.has(id)) {
            const s = this.cache.get(id);
            s.name = name;
            this.cache.set(id, s);
        }
    }
    /**
     * Triggers the reinstall process of a server.
     * @param id The identifier of the server.
     * @example
     * ```
     * client.servers.reinstall('411d2eb9').catch(console.error);
     * ```
     */
    async reinstall(id) {
        await this.client.requests.post(endpoints_1.default.servers.settings.reinstall(id));
    }
}
exports.ClientServerManager = ClientServerManager;
