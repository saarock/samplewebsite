"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubUserManager = void 0;
const Dict_1 = require("../structures/Dict");
const Permissions_1 = require("../structures/Permissions");
const User_1 = require("../structures/User");
const Errors_1 = require("../structures/Errors");
const endpoints_1 = require("./endpoints");
class SubUserManager {
    constructor(client, serverId) {
        this.client = client;
        this.serverId = serverId;
        this.cache = new Dict_1.Dict();
    }
    /**
     * Transforms the raw subuser object(s) into class objects.
     * @param data The resolvable subuser object(s).
     * @returns The resolved subuser object(s).
     */
    _patch(data) {
        if (data?.data) {
            const res = new Dict_1.Dict();
            for (const o of data.data) {
                const s = new User_1.SubUser(this.client, this.serverId, o.attributes);
                res.set(s.uuid, s);
            }
            if (this.client.options.subUsers.cache)
                this.cache.update(res);
            return res;
        }
        const u = new User_1.SubUser(this.client, this.serverId, data.attributes);
        if (this.client.options.subUsers.cache)
            this.cache.set(u.uuid, u);
        return u;
    }
    /**
     * Resolves a subuser from an object. This can be:
     * * a string
     * * a number
     * * an object
     *
     * @param obj The object to resolve from.
     * @returns The resolved user or undefined if not found.
     */
    resolve(obj) {
        if (obj instanceof User_1.SubUser)
            return obj;
        // needed for typing resolution
        if (typeof obj === 'number')
            return undefined;
        if (typeof obj === 'string')
            return this.cache.get(obj);
        if (obj.relationships?.users)
            return this._patch(obj.relationships.users);
        return undefined;
    }
    /**
     * Returns a formatted URL to the subuser.
     * @returns The formatted URL.
     */
    get panelURL() {
        return `${this.client.domain}/server/${this.serverId}/users`;
    }
    async fetch(op, ops = {}) {
        let path = endpoints_1.default.servers.users.main(this.serverId);
        if (typeof op === 'string') {
            if (!ops.force && this.cache.has(op))
                return this.cache.get(op);
            path = endpoints_1.default.servers.users.get(this.serverId, op);
        }
        else {
            if (op)
                ops = op;
        }
        const data = await this.client.requests.get(path, ops);
        return this._patch(data);
    }
    /**
     * Adds a user as a subuser to the server.
     * @param email The email of the account to add.
     * @param permissions Permissions for the account.
     * @returns The new subuser.
     * @example
     * ```
     * const perms = new Permissions(...Permissions.CONTROL, ...Permissions.FILES);
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.add('user@example.com', perms.value)
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async add(email, permissions // TODO: change to permissions
    ) {
        const perms = Permissions_1.Permissions.resolve(...permissions);
        if (!perms.length)
            throw new Errors_1.ValidationError('Need at least 1 permission for the subuser.');
        const data = await this.client.requests.post(endpoints_1.default.servers.users.main(this.serverId), { email, permissions: perms });
        return this._patch(data);
    }
    /**
     * Updates the permissions of a specified subuser.
     * @param id The UUID of the subuser.
     * @param permissions The permissions to set.
     * @returns The updated subuser account.
     * @example
     * ```
     * const perms = new Permissions(...Permissions.FILES, ...Permissions.BACKUPS);
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.setPermissions(
     *  '36de5ed4-8c37-4bde-a1da-4203115a3e9d',
     *  perms.value
     * )
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async setPermissions(id, permissions) {
        const perms = Permissions_1.Permissions.resolve(...permissions);
        if (!perms.length)
            throw new Errors_1.ValidationError('No permissions specified for the subuser.');
        const data = await this.client.requests.post(endpoints_1.default.servers.users.get(this.serverId, id), { permissions: perms });
        return this._patch(data);
    }
    /**
     * Removes a subuser's access to the server.
     * @param id The UUID of the subuser.
     * @example
     * ```
     * const server = await client.servers.fetch('1c639a86');
     * await server.users.remove('9d7b1d20-6e34-4a3a-abcd-c26ae79dc2bd')
     *  .catch(console.error);
     * ```
     */
    async remove(id) {
        await this.client.requests.delete(endpoints_1.default.servers.users.get(this.serverId, id));
        this.cache.delete(id);
    }
}
exports.SubUserManager = SubUserManager;
