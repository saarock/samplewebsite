"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScheduleManager = void 0;
const Dict_1 = require("../structures/Dict");
const Schedule_1 = require("../structures/Schedule");
const Errors_1 = require("../structures/Errors");
const caseConv_1 = require("../util/caseConv");
const endpoints_1 = require("./endpoints");
class ScheduleManager {
    constructor(client) {
        this.client = client;
        this.cache = new Dict_1.Dict();
    }
    /**
     * Transforms the raw schedule object(s) into class objects.
     * @param data The resolvable schedule object(s).
     * @returns The resolved schedule object(s).
     */
    _patch(id, data) {
        if (data.data) {
            const res = new Dict_1.Dict();
            for (let o of data.data) {
                const s = new Schedule_1.Schedule(this.client, id, o.attributes);
                res.set(s.id, s);
            }
            const hold = (this.cache.get(id) || new Dict_1.Dict()).join(res);
            this.cache.set(id, hold);
            return res;
        }
        const s = new Schedule_1.Schedule(this.client, id, data.attributes);
        const hold = (this.cache.get(id) || new Dict_1.Dict()).set(s.id, s);
        this.cache.set(id, hold);
        return s;
    }
    async fetch(server, op1, op2 = {}) {
        let path = endpoints_1.default.servers.schedules.main(server);
        if (typeof op1 === 'number') {
            if (!op2.force && this.cache.get(server)?.has(op1))
                return this.cache.get(server).get(op1);
            path = endpoints_1.default.servers.schedules.get(server, op1);
        }
        else {
            if (op1)
                op2 = op1;
        }
        const data = await this.client.requests.get(path, op2);
        return this._patch(server, data);
    }
    /**
     * Creates a schedule for a specified server.
     * @see {@link CreateScheduleOptions}.
     *
     * @param server The identifier of the server.
     * @param options Create schedule options.
     * @returns The new schedule.
     * @example
     * ```
     * client.schedules.create(
     *  '411d2eb9',
     *  {
     *   name: 'Weekly backup',
     *   active: false,
     *   month: '1',
     *   hour: '*',
     *   minute: '*'
     *  }
     * )
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async create(server, options) {
        options.dayOfWeek ||= '*';
        options.dayOfMonth ||= '*';
        options.onlyWhenOnline ??= false;
        const payload = caseConv_1.default.toSnakeCase(options, {
            map: { active: 'is_active' }
        });
        const data = await this.client.requests.post(endpoints_1.default.servers.schedules.main(server), payload);
        return this._patch(server, data);
    }
    /**
     * Updates a schedule on the specified server.
     * @see {@link CreateScheduleOptions}.
     *
     * @param server The identifier of the server.
     * @param id The ID of the schedule.
     * @param options Update schedule options.
     * @returns The updated schedule.
     * @example
     * ```
     * client.schedules.update('411d2eb9', 5, { onlyWhenOnline: true })
     *  .then(console.log)
     *  .catch(console.error);
     * ```
     */
    async update(server, id, options) {
        if (!Object.keys(options).length)
            throw new Errors_1.ValidationError('Too few options to update schedule.');
        const s = await this.fetch(server, id);
        options.name ||= s.name;
        options.active ||= s.active;
        options.hour ||= s.cron.hour;
        options.minute ||= s.cron.minute;
        options.dayOfWeek ||= s.cron.dayOfWeek;
        options.dayOfMonth ||= s.cron.dayOfMonth;
        options.onlyWhenOnline ??= false;
        const data = await this.client.requests.patch(endpoints_1.default.servers.schedules.get(server, id), caseConv_1.default.toSnakeCase(options));
        return this._patch(server, data);
    }
    /**
     * Deletes a schedule from a specified server.
     * @param server The identifier of the server.
     * @param id The ID of the schedule.
     * @example
     * ```
     * client.schedules.delete('411d2eb9', 3).catch(console.error);
     * ```
     */
    async delete(server, id) {
        await this.client.requests.delete(endpoints_1.default.servers.schedules.get(server, id));
        this.cache.get(server)?.delete(id);
    }
}
exports.ScheduleManager = ScheduleManager;
