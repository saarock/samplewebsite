"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PteroClient = void 0;
const User_1 = require("../structures/User");
const ClientServerManager_1 = require("./ClientServerManager");
const RequestManager_1 = require("../http/RequestManager");
const ScheduleManager_1 = require("./ScheduleManager");
const WebSocketManager_1 = require("./ws/WebSocketManager");
const Errors_1 = require("../structures/Errors");
const endpoints_1 = require("./endpoints");
const config_1 = require("../util/config");
/**
 * The base class for the Pterodactyl client API.
 * This operates using a Pterodactyl client API key which can be found
 * at <your.domain.name/account/api>.
 *
 * **Warning:** Keep your API key private at all times. Exposing this can lead
 * to your accond and servers being corrupted, exposed and/or deleted.
 */
class PteroClient {
    constructor(domain, auth, options = {}) {
        if (!/https?\:\/\/(?:localhost\:\d{4}|[\w\.\-]{3,256})/gi.test(domain))
            throw new Errors_1.ValidationError("Domain URL must start with 'http://' or 'https://' and " +
                'must be bound to a port if using localhost.');
        if (domain.endsWith("/"))
            domain = domain.slice(0, -1);
        this.domain = domain;
        this.auth = auth;
        this.options = config_1.default.clientConfig({ client: options });
        this.account = new User_1.Account(this);
        this.schedules = new ScheduleManager_1.ScheduleManager(this);
        this.servers = new ClientServerManager_1.ClientServerManager(this);
        this.requests = new RequestManager_1.RequestManager('Client', domain, auth);
        this.ws = new WebSocketManager_1.WebSocketManager(this);
    }
    get ping() {
        return this.requests._ping;
    }
    /**
     * Fetches the raw permissions from the API.
     * @see {@link PermissionDescriptor}.
     * @returns The raw permission descriptors.
     */
    async fetchPermissions() {
        const data = await this.requests.get(endpoints_1.default.permissions);
        return data.attributes.permissions;
    }
    /** Performs preload requests to Pterodactyl. */
    async connect() {
        if (this.options.fetchClient)
            await this.account.fetch();
        if (this.options.servers.fetch && this.options.servers.cache)
            await this.servers.fetch();
    }
    addSocketServer(...args) {
        if (args.length === 1)
            return this.ws.createShard(args[0]);
        return args.map(i => this.ws.createShard(i));
    }
    /**
     * Removes a server from websocket connections.
     * @param id The identifier of the server.
     * @returns Whether the shard was removed.
     */
    removeSocketServer(id) {
        return this.ws.deleteShard(id);
    }
    /** Closes any existing websocket connections. */
    disconnect() {
        if (this.ws.active)
            this.ws.destroy();
    }
}
exports.PteroClient = PteroClient;
