"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerBuilder = void 0;
const base_1 = require("./base");
const Errors_1 = require("../structures/Errors");
class ServerBuilder extends base_1.Builder {
    constructor() {
        super();
        this.environment = {};
        this.limits = {
            memory: 128,
            swap: 0,
            disk: 512,
            io: 500,
            cpu: 100,
            threads: null
        };
        this.featureLimits = {
            allocations: 1,
            databases: 1,
            backups: 1
        };
        this.allocation = { default: 0 };
        this.deploy = {
            locations: [],
            dedicatedIp: false,
            portRange: []
        };
    }
    setExternalId(id) {
        this.externalId = id;
        return this;
    }
    setName(name) {
        this.name = name;
        return this;
    }
    setDescription(description) {
        this.description = description;
        return this;
    }
    setUser(user) {
        this.user = typeof user === 'number' ? user : user.id;
        return this;
    }
    setEgg(egg) {
        if (typeof egg === 'number') {
            this.egg = egg;
        }
        else {
            this.egg = egg.id;
            this.dockerImage = Object.values(egg.dockerImages)[0];
            this.startup = egg.startup;
        }
        return this;
    }
    setDockerImage(image) {
        this.dockerImage = image;
        return this;
    }
    setStartup(command) {
        this.startup = command;
        return this;
    }
    setVariable(key, value) {
        this.environment[key] = value;
        return this;
    }
    setEnvironment(variables) {
        this.environment = variables;
        return this;
    }
    setSkipScripts(value) {
        this.skipScripts = value;
        return this;
    }
    setOOMDisabled(value) {
        this.oomDisabled = value;
        return this;
    }
    setLimits(limits) {
        this.limits = Object.assign(this.limits, limits);
        return this;
    }
    setFeatureLimits(featureLimits) {
        this.featureLimits = Object.assign(this.featureLimits, featureLimits);
        return this;
    }
    setAllocation(options) {
        if (options.default)
            this.allocation.default = options.default;
        if (options.additional?.length)
            this.allocation.additional =
                (this.allocation.additional || []).concat(options.additional);
        return this;
    }
    setDeployment(options) {
        if (options.locations?.length)
            this.deploy.locations =
                (this.deploy.locations || []).concat(options.locations);
        if (options.dedicatedIp != undefined)
            this.deploy.dedicatedIp = options.dedicatedIp;
        if (options.portRange?.length)
            this.deploy.portRange =
                (this.deploy.portRange || []).concat(options.portRange);
        return this;
    }
    setStartOnCompletion(value) {
        this.startOnCompletion = value;
        return this;
    }
    build() {
        if (!this.name)
            throw new Errors_1.ValidationError('A server name is required');
        if (!this.user)
            throw new Errors_1.ValidationError('A server owner (user) is required');
        if (!this.egg)
            throw new Errors_1.ValidationError('An egg is required');
        if (!this.dockerImage)
            throw new Errors_1.ValidationError('A docker image is required');
        if (!this.startup)
            throw new Errors_1.ValidationError('A startup command is required');
        if (!this.deploy.locations.length ||
            !this.deploy.portRange.length) {
            if (!this.allocation.default)
                throw new Errors_1.ValidationError('A default allocation or deployment options is required');
        }
        return super.build();
    }
}
exports.ServerBuilder = ServerBuilder;
