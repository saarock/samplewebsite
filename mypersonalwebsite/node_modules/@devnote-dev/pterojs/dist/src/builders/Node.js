"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeBuilder = void 0;
const base_1 = require("./base");
const Errors_1 = require("../structures/Errors");
class NodeBuilder extends base_1.Builder {
    constructor() {
        super();
        this.name = '';
        this.description = undefined;
        this.locationId = 0;
        this.public = false;
        this.fqdn = '';
        this.scheme = '';
        this.behindProxy = false;
        this.memory = 0;
        this.memoryOverallocate = -1;
        this.disk = 0;
        this.diskOverallocate = -1;
        this.daemonBase = '/var/lib/pterodactyl/volumes';
        this.daemonSftp = 2022;
        this.daemonListen = 8080;
        this.maintenanceMode = false;
        this.uploadSize = 0;
    }
    setName(name) {
        this.name = name;
        return this;
    }
    setDescription(description) {
        this.description = description;
        return this;
    }
    setLocationId(id) {
        this.locationId = id;
        return this;
    }
    setPublic(value) {
        this.public = value;
        return this;
    }
    setFQDN(fqdn) {
        this.fqdn = fqdn;
        return this;
    }
    setScheme(scheme) {
        this.scheme = scheme;
        return this;
    }
    setBehindProxy(value) {
        this.behindProxy = value;
        return this;
    }
    setMemory(memory, overallocate) {
        this.memory = memory;
        if (overallocate)
            this.memoryOverallocate = overallocate;
        return this;
    }
    setDisk(disk, overallocate) {
        this.disk = disk;
        if (overallocate)
            this.diskOverallocate = overallocate;
        return this;
    }
    setDaemonBase(base) {
        this.daemonBase = base;
        return this;
    }
    setDaemonSFTP(port) {
        this.daemonSftp = port;
        return this;
    }
    setDaemonListen(port) {
        this.daemonListen = port;
        return this;
    }
    setMaintenance(mode) {
        this.maintenanceMode = mode;
        return this;
    }
    setUploadSize(size) {
        this.uploadSize = size;
        return this;
    }
    build() {
        if (!this.name)
            throw new Errors_1.ValidationError('A node name is required');
        if (!this.locationId)
            throw new Errors_1.ValidationError('A location id is required');
        if (!this.fqdn)
            throw new Errors_1.ValidationError('An FQDN is required');
        if (!this.scheme)
            throw new Errors_1.ValidationError('A HTTP scheme is required');
        if (!this.memory)
            throw new Errors_1.ValidationError('A total memory limit is required');
        if (this.memory < 1)
            throw new Errors_1.ValidationError('Memory cannot be less than 1');
        if (this.memoryOverallocate < -1)
            throw new Errors_1.ValidationError('Overallocated memory cannot be less than -1');
        if (!this.disk)
            throw new Errors_1.ValidationError('A total disk limit is required');
        if (this.disk < 1)
            throw new Errors_1.ValidationError('Disk cannot be less than 1');
        if (this.diskOverallocate < -1)
            throw new Errors_1.ValidationError('Overallocated disk cannot be less than -1');
        if (this.uploadSize < 1 || this.uploadSize > 1024)
            throw new Errors_1.ValidationError('The upload size must be between 1 and 1024');
        return super.build();
    }
}
exports.NodeBuilder = NodeBuilder;
